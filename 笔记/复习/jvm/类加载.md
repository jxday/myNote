## jvm类加载器

##### 类装载方式：

1、隐式装载，在程序运行中碰到new 等方式生成对象时

2、显式装载，通过class.forname()等方法

java类的加载是动态的，并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类完全加载到jvm中，其他类在需要的时候才加载，为了节省内存开销

##### 有哪些类加载器：

1、启动类加载器 Bootstrap ClassLoader：用来加载java核心类库，无法被java程序直接饮用

2、扩展类加载器 Extention ClassLoader：用来加载java的扩展类，jvm的实现会提供一个扩展库目录，该类加载器在此目录里面查找并加载java类。

3、系统类加载器 System ClassLoader：根据java应用的类路径(CLASSPATH)来加载java类，java应用的类都由它来完成加载，可以通过ClassLoader.getSystemClassLoader()来获取它。

4、用户自定义类加载器，通过继承java.lang.ClassLoader类的方式实现。

##### 双亲委派机制：

如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。

##### 类加载的执行过程：

完整流程：加载-验证-准备-解析-初始化-使用-卸载

1、加载：根据查找路径找到相应的class文件，然后导入

2、验证：检查加载的class文件的正确性

3、准备：给类中的静态变量分配内存空间

4、解析：虚拟机将常量池中的符号引用替换成直接引用的过程

5、初始化：对静态变量和静态代码块执行初始化工作

加载阶段与连接阶段的部分内容交叉进行，加载阶段尚未完成，连接阶段可能已经开始了。但这两个阶段的开始时间仍然保持着固定的先后顺序。

##### 加载的过程：

加载是类加载过程的一个阶段，在加载阶段，虚拟机完成3件事：

1、通过类的全限定名获取该类的二进制字节流

2、将二进制字节流所代表的静态结构转化为方法区的运行时数据结构

3、在内存中创建一个代表该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

##### 验证的过程：

验证阶段确保class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。会进行文件格式验证，是否以魔数0xCAFEBABE开头，主次版本号是否在当前虚拟机处理范围内，常量池是否有不被支持的常量类型，指向常量的索引值是否指向了不存在的常量，CONSTANT_Utf8_info型的常量是否有不符合UTF8编码的数据...。元数据验证 对字节码描述信息进行语义分析，确保其符合java语法规范。字节码验证，是验证过程中最复杂的部分，对方法体进行语义分析，确保方法在运行时不会出现危害虚拟机的事件。符号引用验证，本阶段发生在解析阶段，确保解析正常执行。

##### 类初始化的时机：

虚拟机规范中并没有进行强制约束什么时候加载，但是对于初始化，虚拟机规范严格规定了有且只有六种情况必须立即对类进行初始化。

1. 遇到new，getstatic，putstatic或invokestatic这四个字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段，能够生成这四条指令的经典java代码场景有：使用new关键字实例化对象的时候。读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。调用一个类型的静态方法的时候。
2. 使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。
3. 当初始化类的时候，如果发现父类没有进行过初始化，先触发父类的初始化。
4. 当虚拟机启动时，用户需要制定一个要执行的主类，虚拟机会先初始化这个主类。
5. 当使用jdk7新加入的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类还没初始化，则需要先触发其初始化。
6. 当一个接口中定义了jdk8新加入的默认方法(被default关键字修饰的接口方法)时，如果有个接口的实现类发生了初始化，那该接口要在其之前被初始化。

除此之外，所有引用类型的方式都不会触发初始化，成为被动引用。

被动引用:

1. 通过子类引用父类的静态字段，不会导致子类初始化
2. 通过数组定义来引用类，不会触发此类的初始化。数组类本身不通过类加载器创建，是由jvm直接创建，再由类加载器创建数组中的元素类。
3. 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

接口加载过程与类加载过程稍有不同。

当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，当真正用到父接口的时候才会初始化。

