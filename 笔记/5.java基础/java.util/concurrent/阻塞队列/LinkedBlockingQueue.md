有界的阻塞队列（默认Integer.MAX_VALUE=0x7fffffff，有参构造方法设置容量）。FIFO队列，head指向队列等待时间最长的节点，tail时间最短节点。使用尾插法，获取操作从头部获取。链表队列通常具有比基于数组实现的队列更高的吞吐量，原因是添加和删除各有一把锁，互不影响。但是在大多数并发应用程序中，性能较差，原因是产生额外的node对象，处理大批量数据对gc有影响。可选带参数的构造方法是防止链表无限扩展的一种方法，链表的节点在每次插入时新建，除非达到最大容量。通常用来实现生产者-消费者模式。

A variant of the "two lock queue" algorithm. 是两个锁队列算法的变种，通过takeLock来锁住take，poll等方法，notEmpty维护takeLock的阻塞队列。反之亦然。



非阻塞方法是用了double check lock，保证当前队列的情况；而阻塞方法在获取到锁后，再判断是否满足出入队列条件，不满足就阻塞，被唤醒后继续循环，直到满足。以插入为例，第一个插入线程阻塞后，当取出线程拿出节点后放弃takeLock，判断是否notFull，满足则获取putLock唤醒notFull，即使此时其他插入线程又进行插入，第一个插入线程也会再次判断是否仍然满足notFull。



offer(E e)：插入一个元素，不能为null，队列已满就抛弃当前元素，返回false，方法是非阻塞的。

put(E e)：插入元素，不能为null，当队列已满就阻塞当前线程，支持中断操作。判断队列是否已满时，使用while来循环，可以防止虚假唤醒。

poll()：从头部获取并移除一个元素，如果队列为空返回null，方法是非阻塞的。

peek()：从头部获取一个元素，非阻塞。

take()：从头部获取并移除一个元素，阻塞。

remove(E e)：移除指定元素，返回是否成功。操作进行双重加锁，因此是安全的。（ConcurrentLinkedQueue的size和remove都不是可靠的）

size()：当前元素个数，没有加锁，但是因为所有增减节点的操作都加了锁，因此也是比较准确的。对头、尾节点的操作分别使用了单独的独占锁从而保证了原子性。



![image-20200723174804081](/Users/cty/Library/Application Support/typora-user-images/image-20200723174804081.png)