# ReentrantReadWriteLock

>共享锁/独占锁：
>
>公平锁/非公平锁：通过lock方法，调用tryAcquire获取锁的时候，公平锁会调用hasQueuedPredecessors()方法来判断排在队伍前面。注意tryLock方法缺少对writerShouldBlock的调用。
>
>是否可中断：
>
>是否自旋：

读写锁是一种通用技术，并不是Java特有的。从名字来看，读写锁拥有两把锁，`读锁`和`写锁`。读写锁的特点是：同一时刻允许多个线程对共享资源进行读操作；同一时刻只允许一个线程对共享资源进行写操作；当进行写操作时，同一时刻其他线程的读操作会被阻塞；当进行读操作时，同一时刻所有线程的写操作会被阻塞。对于读锁而言，由于同一时刻可以允许多个线程访问共享资源，进行读操作，因此称它为共享锁；而对于写锁而言，同一时刻只允许一个线程访问共享资源，进行写操作，因此称它为排他锁。

- 为什么获取写锁前要先释放读锁？

      if (w == 0 || current != getExclusiveOwnerThread())，tryAcquire方法中的逻辑。

- 为什么释放写锁前要先获取读锁？

    在释放写锁前先获取到读锁，避免先释放写锁，写锁立刻被其他线程获取并更新了缓存，之后再获取读锁读取的数据变成脏数据的问题；