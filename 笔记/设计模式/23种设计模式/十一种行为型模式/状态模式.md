# 状态模式State

>状态类A和B实现handle方法，聚合在环境类中，每次环境类调用handle方法都会更新状态。可以与享元模式一起使用，在环境类中聚合一个享元池。

对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。

状态模式用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题。当系统中某 个对象存在多个状态，这些状态之间可以进行转换，而且对象在不同状态下行为不相同时可 以使用状态模式。状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类 中，使得对象状态可以灵活变化，对于客户端而言，无须关心对象状态的转换以及对象所处 的当前状态，无论对于何种状态的对象，客户端都可以一致处理。



![image-20201130114714862](/Users/cty/Library/Application Support/typora-user-images/image-20201130114714862.png)

<img src="/Users/cty/Library/Application Support/typora-user-images/image-20201130135706942.png" alt="image-20201130135706942" style="zoom:50%;" />

#### 状态模式与责任链模式的区别

状态模式和责任链模式都能消除 if-else 分支过多的问题。但在某些情况下，状态模式中的状态可以理解为责任，那么在这种情况下，两种模式都可以使用。

从定义来看，状态模式强调的是一个对象内在状态的改变，而责任链模式强调的是外部节点对象间的改变。

从代码实现上来看，两者最大的区别就是状态模式的各个状态对象知道自己要进入的下一个状态对象，而责任链模式并不清楚其下一个节点处理对象，因为链式组装由客户端负责。

#### 状态模式与策略模式的区别

状态模式和策略模式的 UML 类图架构几乎完全一样，但两者的应用场景是不一样的。策略模式的多种算法行为择其一都能满足，彼此之间是独立的，用户可自行更换策略算法，而状态模式的各个状态间存在相互关系，彼此之间在一定条件下存在自动切换状态的效果，并且用户无法指定状态，只能设置初始状态。

在实际开发中，状态模式具有较高的使用频率，在工作流和游戏开发中状态 模式都得到了广泛的应用，例如公文状态的转换、游戏中角色的升级等。