# 深入理解java虚拟机

### 对象的内存分布

在hotspot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头Header、实例数据InstanceData、对其填充Padding。

## 3.垃圾回收器和内存分配策略

在java技术体系里面，固定可作为GC Roots的对象包括以下几种：

1. 在虚拟机栈（栈帧中的本地变量表）中引用的对象，比如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
2. 在方法区中类静态属性引用的对象，比如java类的引用类型静态变量。
3. 在方法区中常量引用的对象，比如字符串常量池string table里的引用。
4. 在本地方法栈中JNI 引用的对象。
5. java虚拟机内部的引用，入基本数据类型对应的class对象，一些常驻的异常对象等，还有系统类加载器。
6. 所有被同步锁synchronized关键字持有的对象。
7. 反应java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

#### 引用

JDK1.2以后，对引用的概念进行了扩充，分为强引用，软引用，弱引用和虚引用。

## 7.虚拟机类加载机制

>加载-验证-准备-解析-初始化-使用-卸载

### 7.2类加载的时机

关于在什么情况下需要开始类加载过程的第一个阶段“加载”，虚拟机规范中并没有进行强制约束，但是对于初始化，虚拟机规范严格规定了有且只有六种情况必须立即对类进行初始化。

1. 遇到new，getstatic，putstatic或invokestatic这四个字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段，能够生成这四条指令的经典java代码场景有：使用new关键字实例化对象的时候。读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。调用一个类型的静态方法的时候。
2. 使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。
3. 当初始化类的时候，如果发现弗雷没有进行过初始化，先触发父类的初始化。
4. 当虚拟机启动时，用户需要制定一个要执行的主类，虚拟机会先初始化这个主类。
5. 当使用jdk7新加入的动态语言支持时，四种类型的方法具柄对应的类没有进行过初始化，则需要先触发其初始化。
6. 当一个借口中定义了jdk8新加入的默认方法(被default关键字修饰的接口方法)时，如果有个接口的实现类发生了初始化，那该接口要在其之前被初始化。

除此之外，所有引用类型的方式都不会触发初始化，成为被动引用。

被动引用:

1. 通过子类引用父类的静态字段，不会导致子类初始化
2. 通过数组定义来引用类，不会触发此类的初始化
3. 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

对于接口而言，有区别的只有前面六种的第三种，一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候才会初始化。

- 引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 `java.lang.ClassLoader` 。
- 扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。
- 系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 `ClassLoader.getSystemClassLoader()` 来获取它。

### 加载类的过程

在前面介绍类加载器的代理模式的时候，提到过类加载器会首先代理给其它类加载器来尝试加载某个类。这就意味着真正完成类的加载工作的类加载器和启动这个加载过程的类加载器，有可能不是同一个。真正完成类的加载工作是通过调用 `defineClass` 来实现的；而启动类的加载过程是通过调用 `loadClass` 来实现的。前者称为一个类的定义加载器（defining loader），后者称为初始加载器（initiating loader）。在 Java 虚拟机判断两个类是否相同的时候，使用的是类的定义加载器。也就是说，哪个类加载器启动类的加载过程并不重要，重要的是最终定义这个类的加载器。两种类加载器的关联之处在于：一个类的定义加载器是它引用的其它类的初始加载器。如类 `com.example.Outer` 引用了类 `com.example.Inner` ，则由类 `com.example.Outer` 的定义加载器负责启动类 `com.example.Inner` 的加载过程。

### 8.4动态类型语言支持

动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期进行的

### 8.5基于栈的字节码解释执行引擎

Java代码的时候都有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择。

####  解释执行

