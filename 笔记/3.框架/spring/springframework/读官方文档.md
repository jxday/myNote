# Spring Framework Overview

## Design Philosophy设计哲学

当你了解一个框架时，重要的是不仅要知道它是什么，还要知道它遵循什么原则。

+ provide choice at every level，spring允许你尽可能晚的推迟设计决策，例如你无需更改代码，通过配置来切换持久的服务。
+ accommodate diverse perspectivs，spring支持灵活性，不固执的认为应该如何做事，以不同的视角支持广泛的应用需求。
+ 保持强壮的向下兼容，支持一系列jdk版本和第三方库，以促进依赖于spring的应用程序和库的维护。
+ 关心api设计，spring团队花费了大量的思想和实践来制作直观的api，这些api可以支持多个版本和多年。
+ 为代码质量设置高标准，spring框架强调有意义的、当前的和准确的javadoc。是可以声称代码结构清晰，包之间没有循环依赖关系的项目。

## Core Technologies

>参考文档的这一部分涵盖了spring框架绝对不可或缺的所有技术。
>
>其中最重要的是spring框架的 inversion of control container（IOC容器）紧接着就是spring的面相切面的程序设计 Aspect-Oriented Programming technologies（AOP）。

### 1. The IoC Container

#### 1.1 Introduction to the soring ioc container and beans

对象通过constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method.来定义他们的依赖关系。然后容器在bean创建时，根据类的直接构造方法和服务定位模式来控制依赖项的实例化和位置。

BeanFactory接口是用于管理任意类型的object的根接口，提供了能够接管任何类型对象的高级配置机制。ApplicationContext是BeanFactory的子接口，它增加了：

+ easier integration with spring‘s AOP features更容易与spring的aop特性继承
+ Message resource handling （for use in internationalization）消息资源处理
+ event publication
+ application-layer specific contexts such as the WebApplicationContext for use in web applications      应用层的特定上下文

BeanFactory提供了配置框架和基本功能，ApplicationContext(https://docs.spring.io/spring-framework/docs/5.3.1/javadoc-api/org/springframework/context/ApplicationContext.html)添加了更多特定于企业的功能。ApplicationContext是BeanFactory的一个完整超集，在本章对spring的ioc容器的描述中专门使用。有关beanfactory的内容在1.16

在spring中，构成应用程序主干的对象和由spring IoC容器管理的对象成为bean。bean是由Spring IoC容器实例化、组装和管理的对象。bean以及它们之间的依赖关系反映在容器使用的配置元数据中。

#### 1.2 Container Overview

ApplicationContext 接口表示Spring IoC容器，instantiating, configuring, and assembling the beans负责实例化、配置和装配bean。容器通过读取配置元数据获取关于实例化、配置和组装什么对象的指令。配置元数据用xml、java注释或java代码表示。

spring提供了ApplicationContext接口的几个实现，一般创建ClassPathXmlApplication或FileSystemXmlApplicationContext。xml是定义配置元数据的传统格式，但也可以通过提供少量的xml配置来声明性的支持这些额外的元数据格式，指示容器使用java注释或代码作为元数据格式。

```java
spring基于注解的配置元数据
//在Spring容器内拼凑Bean叫做装配。
//spring容器默认情况下没有开启基于注解的装配。如果要使用基于java注解的元数据，我们需要首先在xml文件中引入context命名空间.然后使用<context:annotation-config/>元素开启spring的注解配置元数据
@Required
注解应用于bean属性的setter方法，它表示受影响的bean属性在配置时必须放在XML配置文件中，否则容器就会抛出一个BeanInitializationException异常。

@Autowired
1. setter方法上的autowired，可以将容器对象根据类型注入到局部变量中。
2. 局部变量上的autowired，可以将容器对象根据类型注入到局部变量中。
3. 构造方法上的autowired，可以将容器对象根据类型注入到构造方法的参数上，仍旧是注入到局部变量中。
4. @Autowired注解有个参数required，默认true，意思是容器中必须有可以获取到的对象来实现注入，否则报异常，设置为false则不会。@Autowired(required = false)
@Qualifier
当容器中存在多个具有相同类型的bean时，可以结合使用@Qualifier和@Autowired指定哪一个真正的bean会被装配。

JSR-250注解：在2.5版本中，spring支持JSR-250注解
@PostConstruct和@PreDestroy：
在spring-config.xml文件配置中，为了定义一个bean的安装和卸载，我们可以使用init-method和destroy-method参数声明。init-method属性指定了一个方法，该方法在bean实例化之后会被立即调用。同样地，destroy-method指定了一个方法，该方法在一个bean从容器中删除之前被调用。
我们可以使用@PostConstruct注解作为初始化回调方法的一个替代，@PreDestroy注解作为销毁回调方法的一个替代。
//测试代码
public class Main {
    public static void main(String[] args) {
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring-config.xml");
        HelloService helloService = applicationContext.getBean("helloService", HelloService.class);
        System.out.println(helloService.getMessage());
        ((ClassPathXmlApplicationContext) applicationContext).registerShutdownHook();
    }
}

@Resource
在字段中或者setter方法中使用@Resource注解，它使用一个name属性，该属性以一个bean名称的形式被注入，也就是说，它遵循byName形式的自动装配
  
@Resource与@Autowired注解的用法很类似，它们的区别如下：
@Autowired注解为Spring提供的注解，只按照byType方式注入，默认情况下，它要求依赖对象必须存在，如果允许为null，可以设置它的required属性为false,如果我们想按照byName方式来装配，可以结合@Qualifier注解一起使用；
@Resource为J2EE提供的注解，它有两个重要的属性：name和type。而默认情况下，@Resource注解按照byName的方式来装配。@Resource的装配顺序是这样的： 
如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。
如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。
如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。
如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。
```

```java
spring基于java代码配置元数据
使用 @Configuration注解表明一个类属于配置类
使用@Import注解引入其他配置类
使用@Bean注解的name属性置顶该bean在spring容器中的名字，initMethod属性指定bean的初始化方法，destoryMethod属性指定bean的销毁方法。
```

##### 1.2.1 Configuration Metadata 配置元数据

spring配置由容器必须管理的至少一个通常不止一个bean定义组成。基于xml的配置元数据将这些bean配置为顶级<beans/>元素中的<bean/>元素。java配置通常在@configuration 类中使用@bean注释的方法。

这些bean定义对应组成应用程序的实际对象。通常定义服务层对象、数据访问对象(dao)、表示对象、基础结构对象等。通常不在容器中配置细粒度的域对象，因为通常是dao和业务逻辑负责创建和加载域对象。但是可以使用spring域aspectJ的集成来配置在IoC容器控件之外创建的对象。

xml中<bean/>元素的id属性是标识单个bean定义的字符串、class属性定义bean的类型，并使用完全限定的类名。

##### 1.2.2 Instantiating a container 实例化容器

提供给ApplicationContext构造函数的位置路径或路径是资源字符串，它允许容器从各种外部资源(本地文件系统、java classpath等)加载配置元数据。

```java
ApplicationContext context = new ClassPathXmlApplicationContext("services.xml","daos.xml");	
```

xml中<bean/>元素的子元素<property/>元素的name属性引用javaBean属性的名称，ref属性引用另一个bean定义的名称。id和ref属性之间的连接表达了合作对象之间的依赖关系。

**Composing XML-based Configuration Metadata 构建基于xml的配置元数据**

让bean定义跨多个xml文件可能是有效的，但通常每个单独的xml配置文件代表体系结构中的一个逻辑层或模块。可以使用applicationContext的构造函数从所有这些xml片段中加载bean定义，即构造函数接受多个资源位置。或者使用一个或多个出现的<import/>元素从另一个文件加载bean定义。

```xml
<beans>
    <import resource="services.xml"/>
    <import resource="resources/messageSource.xml"/>
    <import resource="/resources/themeSource.xml"/>

    <bean id="bean1" class="..."/>
    <bean id="bean2" class="..."/>
</beans>
```

从以下三个文件加载外部bean定义：services.xml、messageSource.xml和themeSource.xml。所有位置路径都相对于执行导入的定义文件，因此services.xml必须域执行导入的文件位于同一目录或类路径位置，而messageS ource.xml和themeSource.xml必须位于导入文件位置之下的资源位置。由于这些路径是相对的，因此前置斜杠/被忽略，最好不要使用斜杠，根据spring schema，导入的文件的内容，包括<beans/>元素，必须是有效的XML bean定义。

<table><tr><td bgcolor="#dcdcdc">
可以但不建议使用相对的“ ../”路径引用父目录中的文件。这样做会在当前应用程序之外的文件上创建一个依赖项。特别是，不建议对classpath：URL（例如，classpath：../ services.xml）使用此引用，在URL中，运行时解析过程会选择“最近的”类路径根目录，然后查看其父目录。类路径配置的更改可能导致选择其他错误的目录。
您总是可以使用完全限定的资源位置而不是相对路径，但是请注意，您正在将应用程序的配置耦合到特定的绝对位置，对于这种绝对位置，通常更可取的做法是保持间接性--例如：在运行时根据JVM系统属性解析的“${...}”占位符。
 </td></tr></table>

**The Groovy Bean Definition DSL Groovy Bean 定义 DSL**

 作为外部化配置元数据的进一步示例，bean定义也可以在Spring的Groovy Bean定义DSL中表示，这样的配置存在于.groovy文件。

##### 1.2.3 Using the container 使用容器

ApplicationContext是高级工厂的接口，它能够维护不同bean及其依赖项，通过使用方法 `T getBean(String name, Class<T> requiredType)`可以检索bean的实例。ApplicationContext允许读取bean定义并访问它们。

```java
// create and configure beans
ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");

// retrieve configured instance
PetStoreService service = context.getBean("petStore", PetStoreService.class);

// use configured instance
List<String> userList = service.getUsernameList();
```

尽管ApplicationContext的getBean和其它一些检索bean的方法可以检索bean实例，但是在理想情况下，您的应用程序代码不应该使用它们，因为这些方法根本不依赖于spring api。spring域web框架的集成为各种web框架组件提供了依赖注入，比如控制器和jsf管理的bean，让你通过元数据声明对特定bean的依赖。

#### 1.3 Bean Overview

在容器本身中，bean定义被标示为`BeanDefinition`对象，其中包括：

+ A package-qualified class name:typically, the actual implementation class of the bean being defined.
+ Bean behavioral configuration elements, which state how the bean should behave in the container(scope,lifecycle callbacks, and so forth).
+ References to other beans that are needed for the bean to do its work.these references are also called collaborators or dependencies.
+ other configuration settings to set in the newly created object - for example, the size limit of the pool or the number of connections to use in a bean that manages a connection pool.

Application的实现还允许由用户创建的在容器之外的现有对象注册，这时通过getBeanFactory方法王文ApplicationContext的BeanFactory来完成的，该方法返回BeanFactory的DefaultlistableBeanFactory的实现，通过registerSingleton()和registerBeanDefinition()方法，但是典型的应用程序(typical applications)只能使用通过常规bean定义元数据定义的bean。

<table><tr><td bgcolor="#dcdcdc">
  Bean元数据和手动提供的单例实例需要尽早注册，以便容器在自动装配和其他自我检测的步骤期间对它们进行适当的推理。虽然在某种程度上支持重写现有的元数据和单例实例，但是对新bean的注册在运行时(或对工厂的实时访问的同时)并没有得到正式的支持，并且可能导致并发访问异常，bean容器中的状态不一致或者两者一起发生。
  </td></tr></table>

##### 1.3.1 Naming Beans

每个bean都有一个或多个标识符identifiers，每个容器中装载的bean的标识符必须是唯一的。一个bean通常只有一个标识符，如果需要多个，那么额外的那些可以被认为是别名aliases。

在xml配置元数据中，使用id属性、name属性来指定bean标识符。id属性允许指定一个id，可以包含特殊字符。如果需要引入别名，可以在name属性中指定它们，中间用逗号,分号;或空白分隔。虽然xml解析器不强制bean id唯一性，但是容器仍然强制bean id唯一性。

不需要为bean提供名称或id，如果没有显示的提供名称或id，容器会为该bean生成唯一的名称。但如果想通过使用ref元素或者一个Service Locator的方式按名称引用该bean，则必须提供一个名称。只有在使用inner beans 和autowiring collcborators时才不需要提供标识符。

[innerBean的定义以及为什么不需要标识符](https://stackoverflow.com/questions/40042493/what-are-inner-beans-in-spring)

<table><tr><td bgcolor="#f0f0f0">
  BeanNamingConventionsBean
  约定是在命名bean时对实例字段名使用标准的java约定，也就是bean名称以小写字母开头，并以驼峰格式显示。
  通过在类路径中进行组建扫描，SPring为未命名的组建生成bean名称，在特殊情况下，当有多个字符且第一个和第二个字符都是大写字母时，原始大小写将得到保留。
  </td></tr></table>

**Aliasing a Bean outside the Bean Definition**

可以在id属性指定的最多一个名称和name属性中任意数量的其他名称的组合。这些名称都属于同一个bean的别名，有时候需要为在别处定义的bean引入别名，在基于xml的配置元数据中，可以使用alias元素来实现：

```xml
<alias name = "formName" alias = "toName"/>
```

原本名为form_name的bean(在同一容器中)也可以被称为toName。

如果使用java-confugiration，也可以使用@bean提供别名

##### 1.3.2 Instantiating beans	初始化beans（3种方法）

Bean定义本质上是创建一个或多个对象的配方，当提出请求时，容器查看命名bean的配方，并使用该bean定义封装的配置元数据来创建(或获取)实际对象。

如果使用基于xml的配置元数据，要在<bean/>元素的<class/>属性中指定实例化的对象的类型(或类)。这个类属性(在内部是BeanDefinition实例上的Class属性)通常是强制的，可以通过两种方式使用class属性：

+ 通常，在容器本身通过反射性地调用其构造函数直接创建Bean的情况下，指定要构造的Bean类，这在某种程度上等同于使用new运算符的Java代码。
+ 要指定包含用于创建对象的静态工厂方法的实际类，在不太常见的情况下，容器在类上调用静态工厂方法以创建Bean。从静态工厂方法的调用返回的对象类型可以是同一类，也可以是完全不同的另一类。

<table><tr><td bgcolor="f1f1f1">
  inner class names	内部类名
  如果要为静态嵌套类 static nested class配置bean定义，则必须使用嵌套类的二进制名称。名称中使用了$字符来分隔嵌套类名和外部类名。
  例如：com.example包中有一个名为SomeThing的类，这个类有一个名为OtherThing的静态嵌套类，那么bean定义中class属性的值应该是com.example.SomeThing$OtherThing

**Instantiation with a Constructor 用构造函数实例化**

springIoC容器实际上可以管理你希望它管理的任何类。

**Instantiation with a Static Factory Method 用静态工厂方法实例化**

在定义用静态工厂方法创建的bean时，使用class属性指定包含静态工厂方法的类和名为factory-method的属性指定工厂方法本身的名称。您应该能通过这个factory-method的方法(带有可选参数)，返回一个活动对象，随后将其视为通过构造函数创建的对象。

```xml
//id:bean的标识符	class:全限定类名	factory-method:静态方法(返回实体的方法，实体的类就是这个class的类)
<bean id="clientService" class="examples.ClientService" factory-method="createInstance"/>
```

**Instantiation by Using an Instance FactoryMethod 使用实例工厂方法实例化**

与通过静态工厂方法进行的实例化类似，使用实例工厂方法进行的实例化从容器中调用现有bean的非静态方法来创建新bean。保留class属性为空。并在factory-bean属性中，在当前(或父或祖先)容器中指定bean的名称，该容器包含要调用来创建对象的实例方法。

```xml
//工厂类：id:工厂类的标识符	class:工厂类的全限定类名
<!-- the factory bean, which contains a method called createInstance() -->
<bean id="serviceLocator" class="examples.DefaultServiceLocator">  <!-- inject any dependencies required by this locator bean --></bean>

//产品类：id:产品类的标识符	factory-bean:工厂类的标识符	factory-method:工厂类返回产品类的方法
<!-- the bean to be created via the factory bean -->
<bean id="clientService" factory-bean="serviceLocator" factory-method="createClientServiceInstance"/>
```

一个工厂类也可以容纳多个工厂方法：

```xml
<bean id="serviceLocator" class="examples.DefaultServiceLocator">
    <!-- inject any dependencies required by this locator bean -->
</bean>

<bean id="clientService"
    factory-bean="serviceLocator"
    factory-method="createClientServiceInstance"/>

<bean id="accountService"
    factory-bean="serviceLocator"
    factory-method="createAccountServiceInstance"/>
```

<table><tr><td bgcolor="f1f1f1">
  在Spring文档中，“ factory bean”是指在Spring容器中配置并通过实例或静态工厂方法创建对象的bean。 相比之下，FactoryBean（请注意大小写）是指特定于Spring的FactoryBean实现类。
</table>

**Determining a Bean's Runtime Type 确定Bean的运行时类型**

确定特定bean的运行时类型并不简单，Bean元数据定义中的指定类仅仅是一个初始类引用，它可能与已声明的工厂方法或FactoryBean类结合在一起，后者可能导致bean的不同运行时类型或者在实例工厂方法的情况下根本不设置类。此外AOP代理可以使用基于接口的代理来包装bean实例，对目标bean的实例类型进行进行有限的公开。

查找特定bean的实际运行时类型的推荐方法是BeanFactory.getType调用指定的bean名称。这将考虑上述所有情况，并返回beanFactory.getBean调用将返回的对象类型。

#### 1.4Dependencies

典型的企业应用程序不包含单个对象(bean)。即使是最简单的应用程序也有一些对象，它们一起工作来呈现终端用户视为一致的应用程序的内容。接下来将解释如何从定义大量独立的bean定义到实现对象协作以实现目标的完全实现的应用程序。

##### 1.4.1 Dependency Injection 依赖注入

依赖注入（DI）是一个过程，对象仅通过 1 构造函数参数，2 工厂方法的参数或 3 在 构造或创建 对象实例后在对象实例上设置的属性 来定义其依赖关系（即，与它们一起工作的其他对象）。然后容器在创建bean时注入那些依赖项。从根本上讲，此过程是通过使用类的直接构造或服务定位器模式来控制bean自身依赖关系的实例化或位置的bean本身的逆过程（因此称为Control Inversion）。

使用DI原理，代码更加简洁，当为对象提供依赖项时，解藕会更加有效。该对象不会定位其依赖项，并且不知道依赖项的位置或类。因此类会变得容易测试，特别是当依赖项依赖于接口或者抽象父类时，它们允许在单元测试中模拟实现。 stub or mock implementations

DI的两个主要的版本：基于构造函数的依赖注入和基于setter的依赖注入。

**Constructor-based Dependency Injection 基于构造器的依赖注入**

基于构造函数的DI是通过容器调用具有许多参数的构造函数来实现的，每个参数表示一个依赖项。调用具有特定参数的静态工厂方法来构造bean几乎是等效的，这里类似的将参数处理为构造函数和静态工厂方法。

**1 Constructor Argument Resolution 构造函数参数解析**

使用参数的类型进行构造函数参数解析匹配。如果bean定义的构造函数参数中没有潜在的歧义，那么在bean定义中定义构造函数参数的顺序就是在bean被实例化时，这些参数被提供给相应的构造函数的顺序。

```java
package x.y;

public class ThingOne {

    public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {
        // ...
    }
}
```

这里的ThingTwo和ThingThree不通过继承关联，不存在潜在的歧义。因此不需要显示地制定构造函数参数的索引或类型

```xml
<beans>
    <bean id="beanOne" class="x.y.ThingOne">
        <constructor-arg ref="beanTwo"/>
        <constructor-arg ref="beanThree"/>
    </bean>

    <bean id="beanTwo" class="x.y.ThingTwo"/>

    <bean id="beanThree" class="x.y.ThingThree"/>
</beans>
```

**1.1 constructor argument type matching 构造函数参数类型匹配**

可以通过<construct-arg>标签的type属性来指定构造函数参数的类型

**1.2 constructor argument index 构造函数参数索引**

可以通过<construct-arg>标签的index属性来指定构造函数参数的索引(index is 0-base 索引从0开始)

**1.3 constructor argument name 构造函数参数名**

可以通过<construct-arg>标签的name属性来指定构造函数参数的参数名，实现这个功能必须在变异代码时开启调试标识(debug flag) ，或者使用@ConstructorProperties 注解，显示地命名构造函数参数。

**2 Setter-based Dependency Injection setter依赖注入**

在调用无参数构造函数或无参数静态工厂方法实例化bean后，bean上的容器调用setter方法可以基于setter的依赖注入。

ApplicationContext支持基于构造函数和基于setter的依赖注入，它也支持通过构造函数方法注入一些依赖项之后进行setter的依赖注入。可以以BeanDefinition的形式配置依赖项，并通过属性编辑器PropertyEditor实例将属性从一种格式转换为另一种格式。但是大多数用户并不直接(以编程方式)使用这些类，而是使用xml bean定义、带注解的组件(用@component、@controller等注释的类)或基于java的@configuration类中的@bean方法。然后将这些源在内部转换为BeanDefinition的实例，并用于加载整个SpringIoC容器实例。

<table><tr><td bicolor = "f2f2f2">
  Constructor-based or setter-based DI
  基于构造函数还是基于setter的依赖注入
  由于可以混合使用基于构造函数和基于setter的依赖注入，因此对于强制依赖项使用构造函数和对于可选依赖项使用setter或配置方法是一个很好的经验法则。注意，在setter方法上使用@required注释可以使该属性成为必须的依赖项，但是带有参数编程验证的构造函数注入更可取。Spring团队提倡构造函数注入，因为它允许您将应用程序组件实现为 不可变 对象，并确保所需的依赖项不为null。此外，注入构造函数的组件总是以完全初始化的状态返回到客户端（调用）代码。附带说明一下，大量的构造函数自变量是一种不好的代码味道，这表明该类可能承担了太多的职责，应该对其进行重构以更好地解决关注点分离问题。
  setter注入应该主要用于可选的依赖项，这些依赖项可以在类中分配合理的默认值。否则必须在代码使用依赖项的所有地方执行非空检查。setter注入的一个好处是setter方法使该类的对象容易在以后重新配置或重新注入。因此，通过JMX mbean进行管理是setter注入的一个引人注目的用例。
  使用对特定类最有意义的依赖注入方式，有时候在处理您没有源的第三方类时，选择是为您做的。例如，如果第三方类没有公开任何setter方法，那么构造函数注入可能是依赖注入唯一可用的形式。

  **Dependency Resolution Process 依赖解析过程**

容器执行bean依赖项解析如下：

+ The ApplicationContext is created and initialized with configuration metadata that describes all the beans.Configuration metadata can be specified by XML,Java code or annotations.使用所有描述bean的配置元数据创建并初始化ApplicationContext。可以通过xml，java代码或注释指定配置元数据。
+ For each bean,it's dependencies are expressed in the form of properties,constructor arguments,or arguments to the static-factory method(if you use that instead of a normal constructor).these dependencies are provided to the bean,when the bean is actually created.对于每个bean，它的依赖关系以属性、构造函数或静态工厂方法的参数的形式表示(如果使用静态工厂方法而不是普通的构造函数)。在实际创建bean时，这些依赖项被提供给bean。
+ Each property or constructor argument is an actual definition of the value to set,or a reference to another bean in the container.每个属性或构造函数参数都是要设置的值的实际定义，或对容器中另一个bean的引用。
+ Each property or constructor argument that is a value is converted from it's soecified format to the actual type of that property or constructor argument.By default,Spring can convert a value supplied in string format to all built in types , such as int,long,String and boolean and so forth.作为值的每个属性或构造函数参数都将从指定的格式转换为该属性或构造函数参数的实际类型。默认情况下，Spring可以将以字符串格式提供的值转换为所有内置类型，如：int、long、String、boolean等。

Spring容器在创建容器时验证每个bean的配置。但是，在bean实际创建之前，不会设置bean属性本身。在创建容器时，将创建单例作用域并设置为预先实例化(默认情况)的bean。作用域在bean作用域中定义。否则只有在请求bean时才会创建它。创建bean可能会导致创建bena图，因为创建和分配bean的依赖项及其依赖项的依赖项等。注意，这些依赖项之间的解析不匹配可能会延迟出现，即在首次创建受影响的bean时出现。

<table><tr><td bgcolor="dcdcdc">Circular dependencies 依赖循环
  		如果主要适用构造函数注入，则有可能创建不可解析的循环依赖关系场景。
  		例如：a类需要通过构造函数注入的b类实例，而b类需要通过构造函数注入的a类实例。如果将bean配置为类a和类b相互注入，那么Spring IoC容器在运行时检测到这个循环引用，并抛出BeanCurrentlyInCreationException。
  		一个可能的解决方案是编辑由setter而不是构造函数配置的某些类的源代码。或者，避免构造函数注入，只使用setter注入。换句话说，尽管不推荐使用setter注入，但是您可以使用setter注入配置循环依赖项。
  		与典型情况(没有循环依赖)不同，bean a 和bean b之间的循环依赖强制其中一个bean在完全初始化之前注入另一个bean(经典的鸡和蛋场景)

通常可以相信Spring会做正确的事情，它在容器加载时检测配置问题，例如对不存在的bean和循环依赖项的引用。SPring在实际创建bean时配置属性并尽可能晚地解析依赖项。这意味着，如果创建对象或其某个依赖项时出现问题，那么正确加载的Spring容器随后可以在请求对象时生成异常---例如，由于缺少或无效属性，bean抛出异常。一些配置问题的可能会延迟，这就是为什么默认情况下ApplicationContext实现会预先实例化单例bean。

**Examples of Dependency Injection 	依赖注入的例子**

```xml
//基于setter的依赖注入，使用xml的配置元数据。
<bean id="exampleBean" class="examples.ExampleBean">
  <property name = "beanOne">
  	<ref bean = "anotherExampleBean"/>
  </property>
  
  <property name = "beanTwo" ref = "yetAnotherBean"/>
  <property name = "integerProperty" value = "1"/>
</bean>
<bean id = "anotherExampleBean" class = "examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/> 

//基于构造函数的依赖注入
<bean id="exampleBean" class="examples.ExampleBean">
    <!-- constructor injection using the nested ref element -->
    <constructor-arg>
        <ref bean="anotherExampleBean"/>
    </constructor-arg>

    <!-- constructor injection using the neater ref attribute -->
    <constructor-arg ref="yetAnotherBean"/>

    <constructor-arg type="int" value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>

//基于静态工厂方法 来返回一个对象的实例
<bean id="exampleBean" class="examples.ExampleBean" factory-method="createInstance">
    <constructor-arg ref="anotherExampleBean"/>
    <constructor-arg ref="yetAnotherBean"/>
    <constructor-arg value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
  
```

静态工厂方法的参数由<constructor-arg>元素提供，与实际使用的构造函数完全相同。工厂方法返回的类的类型不必与包含静态工厂方法的类的类型相同(尽管在本例中是)。实例(非静态)工厂方法可以以本质上相同的方式使用(除了使用factory-bean属性而不是class属性之外)，因此我们在这里不讨论这些细节。



##### 1.4.2	Dependencies and Configuration in Detail 依赖和详细配置

如上文所述，可以将bean属性和构造函数参数定义为对其他托管bean的引用或内联定义的值。spring的基于xml的配置元数据在其<property/>和<constructor-arg/>元素中支持子元素类型。

**Straight Values (Primitives，Strings，and so on)**

元素的value属性将属性或构造函数参数指定为人类可读的字符串表示形式。Spring的转换服务用于将这些值从String转换为属性或参数的实际类型。

```xml
<bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
    <!-- results in a setDriverClassName(String) call -->
    <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
    <property name="url" value="jdbc:mysql://localhost:3306/mydb"/>
    <property name="username" value="root"/>
    <property name="password" value="misterkaoli"/>
</bean>

//p名称空间进行配置
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource"
        destroy-method="close"
        p:driverClassName="com.mysql.jdbc.Driver"
        p:url="jdbc:mysql://localhost:3306/mydb"
        p:username="root"
        p:password="misterkaoli"/>
</beans>

//配置 java.util.Properties 实例
<bean id="mappings"
    class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer">

    <!-- typed as a java.util.Properties -->
    <property name="properties">
        <value>
            jdbc.driver.className=com.mysql.jdbc.Driver
            jdbc.url=jdbc:mysql://localhost:3306/mydb
        </value>
    </property>
</bean>
```

Spring容器通过使用JavaBeans PropertyEditor机制将<value/>元素内的文本转换为java.util.Properties实例。 这是一个很好的捷径，并且是Spring团队偏爱使用嵌套的<value/>元素而不是value属性样式的几个地方之一。

**the `idref` element**

`idref`原属只是一种防错的方法，用于将容器中另一个bean的id(字符串值而不是引用)传给一个<constructor-arg/>或<property/>元素。

```xml
<bean id="theTargetBean" class="..."/>

<bean id="theClientBean" class="...">
    <property name="targetName">
        <idref bean="theTargetBean"/>
    </property>
</bean>
//等价于
<bean id="theTargetBean" class="..." />

<bean id="client" class="...">
    <property name="targetName" value="theTargetBean"/>
</bean>
```

第一种形式比第二种更可取，因为使用idref标记可以让容器在部署时验证所引用的命名bean是否确实存在。在第二个变体中，不对传递给客户端bean的targetName属性的执行验证。只有在实际实例化客户端bean时才会发现输入错误(肯可能会导致致命的结果)。如果客户端bean是一个原型bean，那么只有在部署容器之后很长时间才能发现这个排版错我和由此产生的异常。

<idref />元素带来价值的一个常见地方（至少在Spring 2.0之前的版本中）是在ProxyFactoryBean bean定义中的AOP拦截器的配置中。 在指定拦截器名称时使用<idref/>元素可防止您拼写错误的拦截器ID。

**References to Other Beans (Collaborators)**

Ref 元素是 < constructor-arg/> 或 < property/> 定义元素中的最后一个元素。在这里，您将 bean 的指定属性的值设置为对容器管理的另一个 bean (合作者)的引用。被引用的 bean 是要设置其属性的 bean 的依赖项，并且在设置属性之前根据需要初始化它。(如果合作者是单例 bean，那么它可能已经被容器初始化了。)所有引用最终都是对另一个对象的引用。作用域和验证取决于是否通过 bean 或父属性指定其他对象的 ID 或名称。

通过 < ref/> 标记的 bean 属性指定目标 bean 是最常用的形式，它允许创建对同一容器或父容器中任何 bean 的引用，而不管它是否在同一 XML 文件中。Bean 属性的值可能与目标 bean 的 id 属性相同，或者与目标 bean 的 name 属性中的一个值相同。

```xml
<ref bean="someBean"/>
```

通过父属性指定目标bean将创建对当前容器的父容器中的bean的引用，父属性的值可能与目标bean的id或目标bean的name属性中的一个值相同。目标bean必须位于当前bean的父容器中。当您有一个容器层次结构，并且您希望用与父bean同名的代理将现有bean包装在父容器中时，您应该主要使用这个bean引用变体。

```xml
<!-- in the parent context -->
<bean id="accountService" class="com.something.SimpleAccountService">
    <!-- insert dependencies as required as here -->
</bean>

<!-- in the child (descendant) context -->
<bean id="accountService" <!-- bean name is the same as the parent bean -->
    class="org.springframework.aop.framework.ProxyFactoryBean">
    <property name="target">
        <ref parent="accountService"/> <!-- notice how we refer to the parent bean -->
    </property>
    <!-- insert other configuration and dependencies as required here -->
</bean>
```

**inner beans**

元素中的`property`或`constructory-arg`元素定义了一个内部bean

```xml
<bean id="outer" class="...">
    <!-- instead of using a reference to a target bean, simply define the target bean inline -->
    <property name="target">
        <bean class="com.example.Person"> <!-- this is the inner bean -->
            <property name="name" value="Fiona Apple"/>
            <property name="age" value="25"/>
        </bean>
    </property>
</bean>
```

内部bean 定义不需要定义的id或名称。如果指定，容器不使用此值作为标识符。容器在创建时害忽略范围标识，因为内部bean总是匿名的，而且总是用外部bean创建的。不可能独立地访问内部bean，也不可能将它们注入到合作bean中，而是注入到包围的bean中。

**Collections**

< List/> 、 < Set/> 、 < Map/> 和 < props/> 元素分别设置了 Java Collection 类型 List、 Set、 Map 和 Properties 的属性和参数

**Collection Merging**

Spring容器还支持合并集合。应用程序开发人员可以定义父 < list/> 、 < map/> 、 < set/> 或 < props/> 元素，并让子 < list/> 、 < map/> 、 < set/> 或 < props/> 元素从父集合继承和覆盖值。也就是说，子集合的值是合并父集合和子集合的元素的结果，其中子集合元素重写父集合中指定的值。

```xml
<beans>
    <bean id="parent" abstract="true" class="example.ComplexObject">
        <property name="adminEmails">
            <props>
                <prop key="administrator">administrator@example.com</prop>
                <prop key="support">support@example.com</prop>
            </props>
        </property>
    </bean>
    <bean id="child" parent="parent">
        <property name="adminEmails">
            <!-- the merge is specified on the child collection definition -->
            <props merge="true">
                <prop key="sales">sales@example.com</prop>
                <prop key="support">support@example.co.uk</prop>
            </props>
        </property>
    </bean>
<beans>
```

注意在 child bean 定义的 adminEmails 属性的 < props/> 元素上使用 merge = true 属性。当子 bean 被容器解析并实例化时，结果实例具有 adminEmails Properties 集合，该集合包含将子的 adminEmails 集合与父的 adminEmails 集合合并的结果。下面的清单显示了结果:

`administrator=administrator@example.com
sales=sales@example.com
support=support@example.co.uk`

子 Properties 集合的值集从父 < props/> 继承所有属性元素，子集合的支持值覆盖父集合中的值。

**Limitations of Collection Merging**

不能合并不同的集合类型(如 Map 和 List)。如果您尝试这样做，则会引发适当的 Exception。Merge 属性必须在较低的继承子定义上指定。在父集合定义上指定 merge 属性是多余的，不会导致所需的合并。

**Strongly-typed collection 强类型集合**

通过在 java5中引入泛型类型，您可以使用强类型集合。也就是说，可以声明一个 Collection 类型，这样它就只能包含(例如) String 元素。如果使用 Spring 将一个强类型集合注入到 bean 中，您可以利用 Spring 的类型转换支持，这样您的强类型集合实例的元素在被添加到集合之前就被转换为适当的类型。

**null and empty string values**

Spring 将属性和类似属性的空参数视为空字符串。

```xml
//空字符串
<bean class="ExampleBean">
    <property name="email" value=""/>
</bean>
//null
<bean class="ExampleBean">
    <property name="email">
        <null/>
    </property>
</bean>
```

**XML shortcut with the p-namespace**

P-namespace 允许您使用bean元素的属性(而不是前套的`property`元素)来描述合作bean的属性值，或者两者都使用。

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean name="classic" class="com.example.ExampleBean">
        <property name="email" value="someone@somewhere.com"/>
    </bean>

    <bean name="p-namespace" class="com.example.ExampleBean"
        p:email="someone@somewhere.com"/>
</beans>

<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean name="john-classic" class="com.example.Person">
        <property name="name" value="John Doe"/>
        <property name="spouse" ref="jane"/>
    </bean>

    <bean name="john-modern"
        class="com.example.Person"
        p:name="John Doe"
        p:spouse-ref="jane"/>

    <bean name="jane" class="com.example.Person">
        <property name="name" value="Jane Doe"/>
    </bean>
</beans>
```

**XML shortcut with the c-namespace**

与p命名空间的xml shortcut类似，spring3.1中引入的c命名空间允许内联属性配置构造函数参数。

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:c="http://www.springframework.org/schema/c"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="beanTwo" class="x.y.ThingTwo"/>
    <bean id="beanThree" class="x.y.ThingThree"/>

    <!-- traditional declaration with optional argument names -->
    <bean id="beanOne" class="x.y.ThingOne">
        <constructor-arg name="thingTwo" ref="beanTwo"/>
        <constructor-arg name="thingThree" ref="beanThree"/>
        <constructor-arg name="email" value="something@somewhere.com"/>
    </bean>

    <!-- c-namespace declaration with argument names -->
    <bean id="beanOne" class="x.y.ThingOne" c:thingTwo-ref="beanTwo"
        c:thingThree-ref="beanThree" c:email="something@somewhere.com"/>
		<!-- c-namespace index declaration -->
    <bean id="beanOne" class="x.y.ThingOne" c:_0-ref="beanTwo" c:_1-ref="beanThree"
        c:_2="something@somewhere.com"/>
</beans>
```

**Compound property names 	复合属性名称**

在设置bean属性时，可以使用复合或嵌套属性名，只要路径中除最终属性名以外的所有组件都不为空。

```xml
<bean id="something" class="things.ThingOne">
    <property name="fred.bob.sammy" value="123" />
</bean>
//Something bean 有一个 fred 属性，它有一个 bob 属性，它有一个 sammy 属性，最后一个 sammy 属性被设置为123。为了实现这一点，在构造 bean 之后，某个元素的 fred 属性和 fred 的 bob 属性不能为 null。否则，将引发 NullPointerException。
```

##### 1.4.3	using depends-on

>**depends-on或@DependsOn作用，是用来表示一个bean A的实例化依赖另一个bean B的实例化， 但是A并不需要持有一个B的对象，如果需要的话就不用depends-on，直接用依赖注入就可以了或者ref标签。**

如果一个bean时另一个bean的依赖项，那通常意味着一个bean被设置为另一个bean的属性。通常可以使用基于xml的配置元数据中的`ref`元素来实现这一点。然而，有时bean之间的依赖关系并不那么直接。例如，当需要触发类中的静态初始值设定项时，例如用于数据库驱动程序注册。`depends-on`属性可以在使用该元素初始化bean之前显示的强制初始化一个或多个bean。

```xml
<bean id="beanOne" class="ExampleBean" depends-on="manager"/>
<bean id="manager" class="ManagerBean" />

//多个bean的依赖关系
<bean id="beanOne" class="ExampleBean" depends-on="manager,accountDao">
    <property name="manager" ref="manager" />
</bean>

<bean id="manager" class="ManagerBean" />
<bean id="accountDao" class="x.y.jdbc.JdbcAccountDao" />
```

##### 1.4.4 Lazy-initialized beans

默认情况下，ApplicationContext实现急切地创建和配置所有bean，作为初始化过程的一部分。通常，这种预实例化是可取的，因为配置或 周围环境中的错误会立即被发现，而不是在几小时甚至几天之后。当这种行为不可取时，可以通过将bean定义标记为延迟初始化来防止单一bean的预实例化。一个惰性初始化的bean告诉IoC容器在第一次请求时创建一个bean实例，而不是在启动时。

```xml
<bean id="lazy" class="com.something.ExpensiveToCreateBean" lazy-init="true"/>
<bean name="not.lazy" class="com.something.AnotherBean"/>
<beans default-lazy-init = "true">
		<!-- no beans will be pre-instantiated... -->
</beans>
```

如果一个惰性初始化的bean是一个单例bean的依赖项，而这个单例bean并不是惰性初始化的，那么ApplicationContext会在启动时创建惰性初始化的bean，因为它必须满足单例依赖项。延迟初始化的bean被注入到其他地方的单例bean中，这个单例bean并不是延迟初始化的。

##### 1.4.5	Autowiring collaborators 

spring容器可以自动装配协作bean之间的关系，可以通过检查ApplicationContext的内容，让spring自动为bean解析协作者。

| mode 模式     |                       Explanation 解释                       |
| ------------- | :----------------------------------------------------------: |
| `no`          | 默认没有自动装配。bean引用必须由`ref`元素定义。对于庞大的部署，不建议更改默认设置，因为显示指定协作者可以提供更好的控制和清晰度。在某种程度上，它记录了一个系统的结构。 |
| `byName`      | 按属性名称自动装配。spring查找与需要自动连接的属性名称相同的bean。例如一个bean定义按名称自动装配，并且它包含一个属性`setMaster(args)`,spring查找命名为master的bean定义并且使用它来设置属性。 |
| `byType`      | 如果容器中恰好存在一个属性类型的bean，则允许自动连接属性。如果存在多个则引发异常，这表明不能为该bean使用byType自动装配。如果没有匹配的bean，则什么也不会发生(未设置属性/为null) |
| `constructor` | 类似于`byType`，但适用于构造函数参数。如果容器中没有完全一个构造函数参数类型的bean，将引发严重错误。 |

**limitations and disadvantages of autowiring 自动装配的局限性和缺点**

+ 属性和构造函数参数设置中的显式依赖项总是重写自动装配。不能自动装配简单属性，如原语,`String`,`classes`(以及这种简单属性的数组)，这个限制是设计好的。
+ 自动装配不如直接装配精确。spring再出现可能产生意外结果的模糊性时会小心避免猜测。不再显式记录spring管理的对象之间的关系。
+ 对于可能从spring容器生成文档的工具，链接信息可能不可用
+ 容器中的多个bean定义可能与setter方法或要自动连接的构造函数参数指定的类型相匹配。对于数组、集合或Map实例，这不一定是问题。但是对于期望单个值的依赖项，不能随意解决这种不确定性。如果没有唯一的bean定义可用，则引发异常。
    + 放弃自动装配，使用显式装配
    + 通过将其autowire-candidate属性设置为false来避免为bean定义进行自动装配
    + 通过将其`bean`元素的`primary`设置为true，将单个bean定义指定为主候选项
    + 使用基于注解的配置实现更细粒度的控制。

**excluding a bean from autowiring**

在每个bean的基础上，可以从自动装配中排除bean。在spring的xml格式中，将`bean`元素的autowire-candidate属性设置为false。容器使得自动装配基础设施不能使用特定的bean定义(包括注释样式的配置，如@autowired)

<table><tr><td bgcolor="dcdcdc">autowire-candidate属性设计为仅影响基于类型的自动装配，它不会影响按名称显示的显示引用，即使未将指定的bean标记为自动装配候选，该名称也可得到解析。因此，如果名称匹配，按名称自动装配仍会注入bean<table/>

还可以根据对bean名称的模式匹配来限制自动连接候选对象。顶层`beans`元素在其default-autowire-candidates属性中接受一个或多个模式。例如若要将autowire候选状态限制为名称以repository结尾的任何bean，提供一个值*repository。若要提供多个模式，用逗号分隔的列表中定义它们。bean定义的autowire-candidate属性的显示值true或false始终优先。对于这样的bean，模式匹配的规则并不适用。这些技术对于不希望通过自动装配注入到其他bean中的bean非常有用。这并不意味着不能通过使用自动装配来配置被排除的bean。相反，bean本身并不适合自动装配其他bean。

##### 1.4.6	method injection 方法注入

在大多数应用程序场景中，容器中的大多数bean都是单例的。当一个单例bean需要与另一个单例bean协作，或者一个非单例bean需要与另一个非单例bean协作时，通常通过将一个bean定义为另一个bean的属性来处理依赖关系。当bean的生命周期不同时，问题就出现了。假设单例bean A需要使用非单例(原型)bean B，也许在A上的每个方法调用上都需要。容器只创建单例bean A一次，因此只有一次机会设置属性。每次需要bean B的新实例时，容器不能为bean A提供bean B的新实例。

一个解决方案时放弃一些控制反转。通过实现ApplicationContextAware接口，以及在每次bean A需要时对容器进行getBean("B")，请求(通常是新的)bean B实例，可以让bean A知道容器。

```java
// a class that uses a stateful Command-style class to perform some processing
package fiona.apple;

// Spring-API imports
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

public class CommandManager implements ApplicationContextAware {

    private ApplicationContext applicationContext;

    public Object process(Map commandState) {
        // grab a new instance of the appropriate Command
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    protected Command createCommand() {
        // notice the Spring API dependency!
        return this.applicationContext.getBean("command", Command.class);
    }

    public void setApplicationContext(
            ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
}
```



**lookup method injection	查找方法注入**

> 可以实现动态地创建bean

查找方法注入时容器重写 容器管理bean上的方法 并返回容器中另一个命名bean的查找结果的能力。查找通常涉及一个原型bean，如前面所描述的场景。spring框架通过使用从CGLIB库生成字节码来动态生成覆盖该方法的子类来实现此方法注入。

<table><tr><td bgcolor = "dcdcdc">
  1	为了使这个动态子类化生效，Spring bean容器子类的类不能是final类，而要重写的方法也不能是final
  2	单元测试具有抽象方法的类需要自己对该类进行子类化，并提供抽象方法的具体实现
  3 具体的方法对于组件扫描也是必要的，这需要具体的类来获取
  4 另一个关键限制是查找方法不能与工厂方法一起工作，特别是不能与配置类中的@bean方法一起工作，因为在这种情况下，容器不负责创建实例，因此不能动态创建运行时生成的子类
</table>

```java
package fiona.apple;

// no more Spring imports!

public abstract class CommandManager {

    public Object process(Object commandState) {
        // grab a new instance of the appropriate Command interface
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    // okay... but where is the implementation of this method?
    protected abstract Command createCommand();
}
```

在包含要注入的方法的客户端类中(CommandManager)，要注入的方法需要以下形式的签名：

```xml
<public|protected> [abstract] <return-type> theMethodName(no-arguments);
```

如果该方法是抽象的，则动态生成的子类实现该方法。否则，动态生成的子类将覆盖原始类中定义的具体方法。

```xml
<!-- a stateful bean deployed as a prototype (non-singleton) -->
<bean id="myCommand" class="fiona.apple.AsyncCommand" scope="prototype">
    <!-- inject dependencies here as required -->
</bean>

<!-- commandProcessor uses statefulCommandHelper -->
<bean id="commandManager" class="fiona.apple.CommandManager">
    <lookup-method name="createCommand" bean="myCommand"/>
</bean>
```

标识为`commandManager`的bean在需要myCommand bean的新实例时调用自己的createCommand()方法。如果实际上需要myCommand bean，那么需要谨慎地将其部署为原型。如果是单例模式，则每次返回myCommand bean的相同实例。或者在基于注解的组件模型中，可以通过@lookup声明一个查找方法。

```java
public abstract class CommandManager {

    public Object process(Object commandState) {
        Command command = createCommand();
        command.setState(commandState);
        return command.execute();
    }

    @Lookup("myCommand")
    protected abstract Command createCommand();
}

//或者，更具地道的说，你可以依靠目标 bean 根据声明的返回类型来解析查找方法:
public abstract class CommandManager {

    public Object process(Object commandState) {
        MyCommand command = createCommand();
        command.setState(commandState);
        return command.execute();
    }

    @Lookup
    protected abstract MyCommand createCommand();
}
```

**arbitrary method replacement	任意方法替换**

与查找方法注入相比，方法注入的一个不太有用的形式是用另一个方法实现替换托管bean中的任意方法的能力。



#### 1.5 bean scopes

创建bean定义时，将创建一个配方，用于创建该bean定义所定义的类的实际实例。 bean定义是配方的想法很重要，因为它意味着与类一样，您可以从一个配方中创建许多对象实例。

您不仅可以控制要插入到 特定bean定义创建的对象中的 各种依赖项和配置值，还可以控制范围。这种方法是强大且灵活的，因为可以选择通过配置创建的对象的范围，而不必在java类级别的对象范围内进行操作。可以将bean定义为部署在许多作用域中的一个。spring框架支持六个作用域，其中四个作用域只有在使用一个web-aware ApplicationContext时才可用。

| Scope 范围  | Description 描述                                             |
| ----------- | ------------------------------------------------------------ |
| singleton   | 默认值，将每个Spring IoC容器的单个bean定义范围限定为单个对象实例。 |
| prototype   | 将单个bean定义的作用域限定为任意数量的对象实例。             |
| requesst    | 将单个bean定义的作用域限定为单个HTTP请求的生命周期。也就是说，每个HTTP请求都有一个自己的bean实例，它是在单个bean定义的后面创建的。仅在web-aware ApplicationContext上下文中有效。 |
| session     | 将单个bean定义的作用域限定为HTTP会话的生命周期。仅在web-aware ApplicationContext上下文中有效。 |
| application | 将单个bean定义的作用域限定为ServletContext的生命周期，仅在web-aware ApplicationContext上下文中有效。 |
| websocket   | 将一个bean定义的作用域限定为websocket生命周期。仅在web-aware ApplicationContext上下文中有效。 |

##### 1.5.1	the singleton scope

一个singleton bean只管理一个被共享的bean实例，对id或与bean定义相匹配的ids的请求都将获得spring容器返回一个特定bean实例。换句话说，当定义一个bean并将其作用域定为单例时，Spring IoC容器只创建由该bean定义 定义的对象的一个实例，这些singleton beans的唯一的实例存储在缓存中，并且对于这个命名bean的锁哦呦后续请求和引用都返回缓存的对象。spring的单例模式的范围被描述为每个容器和每个bean，也就是说在单个spring容器中为特定`类定义`一个bean，那么spring容器将创建由该`bean定义` 定义的类的一个且仅有一个实例。singleton scope 是spring中的默认scope。

```xml
<bean id="accountService" class="com.something.DefaultAccountService"/>

<!-- the following is equivalent, though redundant (singleton scope is the default) -->
<bean id="accountService" class="com.something.DefaultAccountService" scope="singleton"/>
```

<img src="/Users/cty/Library/Application Support/typora-user-images/image-20201222150934385.png" alt="image-20201222150934385" style="zoom:50%;" />

##### 1.5.2 the prototype scope

bean部署在non-singleton prototype scope导致每次对特定bean发出请求时都会创建一个新的bean实例。也就是说，prototype bean被注入到另一个bean中，或者您通过容器上的getBean()方法调用请求它。(数据访问对象(DAO)通常不配置为原型，因为典型的 DAO 不包含任何会话状态。对我们来说，重用单例图的核心更容易)

与其他范围不同，spring不管理prototype bean的整个生命周期。容器实例化，配置并组装一个prototype对象，然后将其交给客户机，并不再进一步记录该prototype实例。因此，尽管初始化生命周期不管作用域时什么都会被调用回调方法，但是在prototype的情况下，不会调用已配置的销毁(destory)生命周期回调。客户机代码必须清理prototype scope对象，并释放prototype bean所拥有的资源。要让spring容器释放prototype scope bean所持有的资源，可以尝试使用 bean post-processor。

<img src="/Users/cty/Library/Application Support/typora-user-images/image-20201222151149441.png" alt="image-20201222151149441" style="zoom:50%;" />

##### 1.5.3	singleton beans with prototype-bean dependencies

当使用singleton-scope与prototype beans的依赖关系时，请注意依赖关系在实例化时被解析。因此，将prototype scope bean注入到singleton scope bean中，那么就会实例化一个新的prototype bean，然后依赖性地注入到 singleton 实例bean中，prototype 实例时曾经提供给singleton scope bean的唯一实例。

但是如果希望singleton scope bean在运行时重复获取prototype scope bean的新实例，不能依赖性地将prototype scope bean 注入到 singleton bean 中，需要使用 lookup method或者给singleton bean注入一个`ApplicationContext`或`BeanFactory`然后需要使用prototype类型的时候从注入的上下文或工厂通过调用`getBean()`方法获取新的实例。

##### 1.5.4 request,session,application and websocket scopes

`request`，`session`，`application`，`websocket`作用域只有在使用 web-aware spring applicationContext 实现(例如XmlWebApplicationContext)时才可用。如果将这些作用域与常规SpringIoC容器(如ClassPathXmlApplicationContext)一起使用，会抛出关于未知bean作用域的IllegalStateException。

**initial web configuration	初识网页配置**

如果在Spring Web MVC中访问作用域bean，实际上，在Spring DispatcherServlet处理的请求中，不需要特殊设置，DIspatcherServlet已经公开了所有相关的状态。

如果使用Servlet 2.5web容器，并在Spring的DispatcherServlet之外处理请求(例如，在使用JSF或Struts时)，则需要注册`org.springframework.web.xml.context.request`。请求上下文监听器ServletRequestListener。对于Servlet 3.0+，这可以通过使用WebApplicationInitializer接口以编程方式完成。或者对于较旧的容器，将一下声明添加到web应用程序的`web.xml`文件

```xml
<web-app>
    ...
    <listener>
        <listener-class>
            org.springframework.web.context.request.RequestContextListener
        </listener-class>
    </listener>
    ...
</web-app>

//如果监听器设置有问题，可以考虑使用spring的requestContextFilter。过滤器映射取决于周围的web应用程序配置
<web-app>
    ...
    <filter>
        <filter-name>requestContextFilter</filter-name>
        <filter-class>org.springframework.web.filter.RequestContextFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>requestContextFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>
    ...
</web-app>
```

`DispatchServlet`，`RequestContextListener`，`RequestContextFilter`都做完全相同的事情，将HTTP请求对象绑定到服务该请求的Thread，这使得请求范围和会话范围的bean在调用链的下一级可用。

**Request scope **

spring容器通过为每个http请求使用`loginAction`bean定义来创建`LoginAction`bean实例。也就是说，loginAction bean 的作用域在http请求级别。可以根据需要随意更改所创建的实例的内部状态，因为从同一loginAction bean 定义 创建的其他实例不会看到这些状态更改。它们特定于单个请求，当请求完成处理时，该请求作用域的bean被抛弃。

当使用注解驱动的组件或java配置时，可以使用`@RequestScope`注释将组件分配给request scope。

```java
@RequestScope
@Component
public class LoginAction {
    // ...
}
```

**session scope**

spring容器通过在单个http session的生存期内使用UserPreferences bean 定义创建UserPreferences bean的新实例。userPreferences bean有效地限定在http session 级别。与使用请求作用域的bean一样，可以随意更改创建的实例的内部状态。因为同样使用从相同userPreferences bean定义创建的实例的其他http session实例不会看到这些状态更改。当http会话结束时，该http session作用域的bean也会被丢弃。

```java
@SessionScope
@Component
public class UserPreferences {
    // ...
}
```

**Application scope**

spring容器 通过 对整个web应用程序使用一次 `appPreferences`bean定义	创建AppPreferences bean的新实例。也就是说，appPreferences bean的作用域在ServletContext级别，并作为常规ServletContext属性存储。这有点类似于spring单例bean，但有两个重要方面不同：每个`servletContext`对应一个单例，而不是spring applicationContext(在任何给定的web应用程序中都可能是多个)

```java
@ApplicationScope
@Component
public class AppPreferences {
    // ...
}
```

**scoped beans as dependencies **

Spring Ioc conatiner 管理的不仅是实例化你的beans,也可以聚合一堆beans就行包裹。如果你把一个HTTP request-scoped bean注入另一个生命周期更长的scope,你也可以选择注入一个AOP PROXY代替 这个scope bean。

也就是说，您需要注入一个代理对象，该对象和scope对象相同的public interface，但也可以从相关scope（例如HTTP请求）中检索实际目标对象，并将方法调用委托给实际对象。

也就是说，你需要注入一个代理对象，该对象暴露与范围对象相同的公共接口，但也可以从相关范围（例如HTTP请求）中检索实际目标对象，并将方法调用委托给实际对象。

>在这些`bean`作用域是单例之间，你可以使用 `<aop:scoped-proxy/>`。然后通过一个可序列化的中间代理引用，从而能够在反序列化时重新获得目标单例`bean`。
>
>当申明 `<aop:scoped-proxy/>`原型作用域`bean`，每个方法调用共享代理导致一个新目标实例被创建，然后将该调用转发到该目标实例。
>
>同样，作用域代理不是以生命周期安全的方式从较短的作用域访问`bean`的唯一方法。你也可以声明你的注入点(也就是，构造函数或者`Setter`参数或自动注入字段)例如：`ObjectFactory<MyTargetBean>`，允许`getObject（）`调用在每次需要时按需检索当前实例-不保留实例或单独存储实例。
>
>作为一个扩展的变体，你可以声明`ObjectProvider<MyTargetBean>`，提供了一些附加的获取方式，包括`getIfAvailable`和`getIfUnique`。
>
>JSR-330的这种变体称为`Provider`，并与`Provider <MyTargetBean>`声明和每次检索尝试的相应`get()`调用一起使用。

```java
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd">

    <!-- 一个HTTP Session作用域的bean暴露为一个代理 -->
    <bean id="userPreferences" class="com.something.UserPreferences" scope="session">
        <!-- 指示容器代理周围的bean -->
        <aop:scoped-proxy/> //1.
    </bean>

    <!-- 一个单例作用域bean 被注入一个上面的代理bean -->
    <bean id="userService" class="com.something.SimpleUserService">
        <!-- a reference to the proxied userPreferences bean -->
        <property name="userPreferences" ref="userPreferences"/>
    </bean>
</beans>
//1.这行定义代理
```

创建一个代理，将`aop:scoped-Proxy`元素插入到一个scoped bean定义中。

为什么在请求、会话、自定义范围级别 定义的bean scope需要`aop:scoped-Proxy`元素？

在示例中，单例bean被注入一个引用到http session作用域的bean。其中userManager是一个单例bean，这个实例在每个容器值初始化一次，并且它的依赖仅仅被注入一次。这意味着userManager运行时都是使用相同的userPreferences对象(也就是最初注入的那个)。

当一个短生命周期作用域的bean注入到一个长生命周期作用域bean的时候，这并不是我们期望的结果。相反，需要一个userManager对象，并且在每个http会话的生命周期内，都需要一个特定于http会话的userPreferences对象。因此，容器创建一个对象，该对象公开与userPerferences类完全相同的公共接口(理想情况下是一个 UserPreferences 实例的对象) ，该对象可以从作用域机制(http请求，session等)中获取真正的userPreferences对象。容器将这个代理对象注入到userManager bean中，而userPerferences引用并不知道这是一个代理。当userManager实例调用依赖注入的userPreferences对象上的方法时，实际上是调用代理上的方法，然后代理从http session获取真实的userPerferences对象，并将方法调用委托给检索到的真实userPreferences对象。

**choosing the type of proxy to create**

默认情况下，当spring容器为用`aop:scoped-proxy`元素标记的bean创建代理时，将创建一个基于cglib的类代理。

>`CGLIB`代理拦截器仅仅公共方法被调用！在代理上不要调用非公共方法。spring aop只会检测到public方法。

或者可以配置spring容器，通过为`aop:scoped-proxy`元素的`proxy-target-class`属性值指定为fales，为这种作用域bean创建基于jdk接口的代理。

```xml
<!-- DefaultUserPreferences implements the UserPreferences interface -->
<bean id="userPreferences" class="com.stuff.DefaultUserPreferences" scope="session">
    <aop:scoped-proxy proxy-target-class="false"/>
</bean>

<bean id="userManager" class="com.stuff.UserManager">
    <property name="userPreferences" ref="userPreferences"/>
</bean>
```

##### 1.5.5	custom scopes	自定义scope

bean作用域机制是可拓展的，可以自定义甚至重新定义现有的scopes，尽管后者被认为是不好的做法并且不可以覆盖内置的singleton和prototype scopes。

**creating a custom scope**

要将自定义scope 集成到spring容器中 ，需要实现`org.springframework.beans.factory.config.scope`接口。

scope接口有四种方法来 获取作用域中的对象，将其从作用域中删除并销毁。

```java
//session scope实现 返回一个session作用域的bean，如果bean不存在，将返回一个新的bean，并绑定到session scope。
Object get(String name, ObjectFactory<?> objectFactory)
  
//session scope实现 将session的bean从session中删除并返回，如果找不到具有指定名称的对象，则返回null。
Object remove(String name)

//该方法注册了一个毁掉，当范围被销毁或范围中指定的对象被销毁时，调用该方法
void registerDestructionCallback(String name, Runnable destructionCallback)

//该方法获取 underlying scope的标识
String getConversationId()  
```

**using a custom scope**

```java
//用spring ring起注册一个新scope的方法
//第一个参数是与作用域关联的唯一名称，例如singleton，prototype
//第二个参数是希望注册和使用的自定义scope实现的是在实际实例
void registerScope(String scopeName, Scope scope);
```

这个方法在ConfigurableBeanFactory接口上声明，该接口可通过spring附带的大多数具体ApplicationContext实现上的BeanFactory属性获得。

> 接下来例子使用`SimpleThreadScope`，它包括`Spring`但是默认是不被注册的。对于你自己的自定义范围实现，是相同的。

```java
Scope threadScope = new SimpleThreadScope();
//注册自定义作用域
beanFactory.registerScope("thread", threadScope);
//然后，你可以按照你的自定义范围的作用域规则创建bean定义
```

通过自定义`Scope`实现，你不仅限于以编程方式注册作用域。你可以声明式注册Scope，通过使用`CustomScopeConfigurer`，类似下面的例子：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd">

    <bean class="org.springframework.beans.factory.config.CustomScopeConfigurer">
        <property name="scopes">
            <map>
                <entry key="thread">
                    <bean class="org.springframework.context.support.SimpleThreadScope"/>
                </entry>
            </map>
        </property>
    </bean>

    <bean id="thing2" class="x.y.Thing2" scope="thread">
        <property name="name" value="Rick"/>
        <aop:scoped-proxy/>
    </bean>

    <bean id="thing1" class="x.y.Thing1">
        <property name="thing2" ref="thing2"/>
    </bean>

</beans>
```

> 当在`FactoryBean`实现中配置`<aop:scoped-proxy/>`时，限定作用域的是`factorybean`本身，而不是从`getObject()`返回对象。

#### 1.6	customizing the nature of a bean	定制bean的本质

spring框架提供了许多接口，可以使用它们来定义bean的本质：

+ lifecycle callbacks	生命周期回调
+ ApplicationContextAware and BeanNameAware  上下文和bean名称
+ other Aware Interfaces   其他aware接口

<img src="/Users/cty/Library/Application Support/typora-user-images/image-20201228113605852.png" alt="image-20201228113605852" style="zoom:50%;" />

##### 1.6.1   lifeCycle callbacks   生命周期回调

实现Spring initializingBean和DisposableBean接口，与bean生命周期的容器的管理器进行交互。容器调用前者的afterPropertiesSet()，后者的destory()方法，让bean在初始化和销毁bean时执行某些操作。

> JSR-250的`@PostConstruct`和`@PreDestory`注释通常被认为是在当前spring应用程序中接收生命周期回调的最佳实践。使用这些注释意味着bean没有耦合到特定于spring的接口。
>
> 也可以考虑`init-method`和`destroy-method`bean定义元数据

在内部，spring框架使用BeanPostProcessor实现来处理它能够找到并调用适当方法的任何回调接口。如果需要自定义特性或者其他spring默认不提供的生命周期行为，可以自己实现BeanPostProcessor。

除了初始化和销毁回调之外，spring管理的对象还可以实现`lifecycle`接口，以便这些对象能够参与启动和关闭过程，这是由容器自身的生命周期驱动的。

**Initialization Callbacks	初始化回调**

`org.springframework.beans.factory.InitializingBean`接口允许bean在 容器设置了bean的所有必要属性之后 可以执行初始化工作，`InitializingBean`接口指定了一个方法：

```java
void afterPropertiesSet() throws Exception;
```

建议不要使用`initializingBean`接口，因为它不必要地将代码与spring挂钩。或者建议使用`@postconstruct`注释或指定POJO初始化方法。对于基于xml的配置元数据，init-method属性指定具有无效无参数签名的方法的名称。使用java配置，可以用`@bean`的initMethod属性。

```xml
<bean id = "exampleInitBean" class = "examples.ExampleBean" init-method= "init"/>
```

```java
public class ExampleBean{
	
	public void init(){
			//	do some initialization work
	}
}
//使用@Bean注解的name属性置顶该bean在spring容器中的名字，initMethod属性指定bean的初始化方法，destoryMethod属性指定bean的销毁方法。
```



```xml
<bean id = "exampleInitBean" class = "examples.AnotherExampleBean"/>
```

```java
public class AnotherExampleBean implements InitializingBean{
	
	@Override
	public void afterPropertiesSet(){
			//	do some initialization work
	}
}
```

>1：spring为bean提供了两种初始化bean的方式，实现InitializingBean接口，实现afterPropertiesSet方法，或者在配置文件中同过init-method指定，两种方式可以同时使用
>2：实现InitializingBean接口是直接调用afterPropertiesSet方法，比通过反射调用init-method指定的方法效率相对来说要高点。但是init-method方式消除了对spring的依赖
>3：如果调用afterPropertiesSet方法时出错，则不调用init-method指定的方法。
>
>4 ：spring bean的初始化执行顺序：构造方法 --> `@PostConstruct`注解的方法 --> `afterPropertiesSet`方法 --> `init-method`指定的方法。
>
>5 ：`afterPropertiesSet`通过接口实现方式调用（效率上高一点），`@PostConstruct`和`init-method`都是通过反射机制调用

**destruction callbacks	销毁回调**

实现`org.springframework.beans.factory.DisposableBean`接口允许bean在它所在的容器销毁时获得一次回调。`DisposableBean`接口指定了一个方法。

```java
void destory() throws Exception;
```

建议不要使用`disposableBean`接口，而使用`@predestory`注释或指定bean定义支持的通用方法。对于基于xml的配置元数据，可以在<bean/>上使用destory-method属性。使用java配置，可以使用@bean的destoryMethod属性。

```xml
<bean id = "exampleInitBean" class = "examples.ExampleBean" destory-method = "cleanup"/>
```

```java
public class ExampleBean{
	
		public void cleanup(){
				//do some destruction work(like releasing pooled connections)
		}
}
```



```xml
<bean id = "exampleInitBean" class = "examples.AnptherExampleBean" />
```

```java
public class AnotherExampleBean implements DisposableBean{

	@Override
	public void destory(){
			//do some destruction work(like releasing pooled connections)
	}
}
```

> <bean/>元素的`destory-method`属性可以分配一个特殊的(推断)值，该值指示spring自动检测特定bean类上的public close或shutdown方法。(因此，任何实现`java.lang.AutoCloseable`或`java.io.Closeable`的类都将匹配)。还可以在<beans/>元素的`default-destory-method`属性上设置此特殊值，

**default initialization and destory methods	默认初始化和销毁方法**

在编写不使用spring特定的`initializingBean`和`DisposableBean`回调接口的初始化和销毁 方法回调时，通常使用init()，initialize()，dispose()等名称编写方法。理想情况下，这种生命周期回调方法的名称在项目中是标准化的，这样所有开发人员都使用相同的方法名称，并确保一致性。

可以将spring容器配置为"查找"每个bean上的 初始化和销毁 回调方法的名称，也就是说，可以编写应用程序类，并使用名为init()的初始化回调，而不必为每个bean定义 配置init-method=“init” 属性。spring IoC容器在创建bean时(并根据前面描述的标准生命周期回调契约)调用该方法。这个特性还强制执行 初始化和销毁 方法回调使用一致变量名原则。

```xml
<beans default-init-method = "init">
	...
<beans/>
```

顶级<bean/>元素属性上的default-init-method属性的存在使spring IoC容器将bean类上命名为init的方法识别为初始化方法回调。在创建和组装bean时，如果bean类 有此方法，则在适当的时候调用它。

**combining lifecycle mechanisms	结合生命周期机制**

spring控制bean生命周期行为的三个选型：

+ `InitializingBean`和`Disposablebean`回调接口
+ 自定义`init()`和`destory()`方法
+ 使用`@PostConstruct`和`@PreDestory`注释

> 如果一个bean配置了多个生命周期机制，并且为每个机制配置了不同的方法名称，则每个配置的方法都会按照此注释后列出的顺序运行。但是，如果为多个生命周期机制中的多个生命周期配置了相同的方法名称，则该方法将运行一次。

初始化方法：@PostConstruct	->	InitializingBean的afterPropertiesSet()	->	自定义的init()

销毁方法：@PreDestory	->	DisposableBean的destroy()	->	自定义的destroy()

**startup and shutdown callbacks	启动和关闭回调**

`lifecycle`接口为任何具有自己的生命周期需求的对象定义基本方法(例如启动和停止某个后台流程)

```java
public interface Lifecycle {
    /**
     * 启动当前组件
     * <p>如果组件已经在运行，不应该抛出异常
     * <p>在容器的情况下，这会将 开始信号 传播到应用的所有组件中去。
     */
    void start();
    /**
     * (1)通常以同步方式停止该组件，当该方法执行完成后,该组件会被完全停止。当需要异步停    
         * 止行为时，考虑实现SmartLifecycle 和它的 stop(Runnable) 方法变体。

注意，此停止通知在销毁前不能保证到达:在常规关闭时，{@code Lifecycle} bean将首先收到一个停止通知，然后才传播常规销毁回调;然而，在上下文的生命周期内的热刷新或中止的刷新尝试上，只调用销毁方法
对于容器，这将把停止信号传播到应用的所有组件*
     */
    void stop();

    /**
      *  检查此组件是否正在运行。
      *  1. 只有该方法返回false时，start方法才会被执行。
      *  2. 只有该方法返回true时，stop(Runnable callback)或stop()方法才会被执行。
      */
    boolean isRunning();
}
```

任何spring管理的对象都可以实现`lifecycle`接口，当`ApplicationContext`调用启动和停止方法时，将这些调用传递给该上下文中定义的所有lifecycle实现。它通过委托给一个lifecycleProcessor来实现这一点。

```java
//lifecycleProcessor本身就是Lifecycle接口的拓展，添加了两个方法，用于对刷新和关闭的上下文做出反应
public interface LifecycleProcessor extends Lifecycle {
		void onRefresh();
		
		void onColse();
}
```

> 常规的`org.springframework.context.Lifecycle`接口是显示启动和停止通知的普通契约，并不意味着在上下文刷新时自动启动。对与特定bean(包括启动阶段 startup phases)的自动启动的细粒度控制，可以考虑实现`org.springframework.context.SmartLifecycle`来代替
>
> 另外，停止通知并不保证会在销毁之前到来。在定期关闭时，所有lifecyclebean在传播常规销毁回调之前首先收到停止通知。但是，在上下文生存期内的热刷新或停止刷新尝试时，只调用destory方法。

启动和关闭调用的顺序是很重要的。如果两个对象之间存在依赖关系，依赖类要在其依赖类后启动，依赖类也要在其依赖类前停止。然而有时候其之间的依赖关系不是那么直接。你可能仅仅知道某种类型的对象应该在另一类型对象前启动。在那些情况下，SmartLifecycle接口定义了另一个选项，在其父类接口Phased中定义命名为getPhase()方法。

当启动时，有最低phase的对象首先启动，并且停止时，按照相反的顺序结束。因此，实现了`SmartLifecycle`接口并且其`getPhase()`方法返回`Integer.MIN_VALUE`的一个对象将是首先被启动并且最后停止。与其相反对应的对象，Integer.MAX_VALUE的phase的值，将指明最后启动和最先停止（可能是其依赖其他对象工作运行）。当考虑phase值时，了解任何普通Lifecycle对象（没有实现SmartLifecycle其值将是0）的默认phase也很重要。因此，任何负数phase值将表示对象应该在那些标准组件前启动（并其之后停止），并且对于正数的phase值按照相反顺序启动停止

如你在SmartLifecycle接口中定义的stop方法内有一回调参数。任何实现类在其关闭完成后必须调用回调的run方法。必须的时候由于实现了LifecycleProcessor接口的实现类可以进行异步关闭操作，DefaultLifecycleProcessor对于在每个phase调用那个回调内的对象组将等待一个超时时间。默认的每个phase的超时是30秒。你可以通过在上下文内定义一个命名为lifecycleProcessor的bean重写默认的生命周期处理器实例。如果你仅仅想修改超时时间，如下定义将会很有用：

```xml
<bean id="lifecycleProcessor"class="org.springframework.context.support.DefaultLifecycleProcessor">  
  <!-- timeout value in milliseconds -->  
  <property name="timeoutPerShutdownPhase" value="10000"/>  
</bean>  
```

LifecycleProcessor接口定义了回调方法来刷新和关闭上下文。后者仅简单地做关闭处理如同直接地调用stop方法，但是当关闭上下文时生效。刷新回调使得SmartLifecycle bean的另一个功能起作用。当上下文刷新时(在所有的对象实例化和初始化后)，将调用那个回调，并且在那个点上，默认的生命周期处理器将检查每个SmartLifecycle对象的isAutoStartup()方法的返回值。如果时true，那么对象将在那个点上启动而不是等一个上下文的明确调用或者等其自己的start()方法(不像上下文的刷新，上下文启动对于标准的上下文实现不是自动发生的)phase值与依赖关系一样将如上所述决定了启动顺序。

```java
package com.dreams.demo.spring;

import org.springframework.context.SmartLifecycle;
import org.springframework.stereotype.Component;

@Component
public class SmartLifecycleTest implements SmartLifecycle {

    private boolean isRunning = false;

    /**
     * 1. 我们主要在该方法中启动任务或者其他异步服务，比如开启MQ接收消息<br/>
     * 2. 当上下文被刷新（所有对象已被实例化和初始化之后）时，将调用该方法，默认生命周期处理器将检查每个SmartLifecycle对象的isAutoStartup()方法返回的布尔值。
     * 如果为“true”，则该方法会被调用，而不是等待显式调用自己的start()方法。
     */
    @Override
    public void start() {
        System.out.println("start");

        // 执行完其他业务后，可以修改 isRunning = true
        isRunning = true;
    }

    /**
     * 如果工程中有多个实现接口SmartLifecycle的类，则这些类的start的执行顺序按getPhase方法返回值从小到大执行。<br/>
     * 例如：1比2先执行，-1比0先执行。 stop方法的执行顺序则相反，getPhase返回值较大类的stop方法先被调用，小的后被调用。
     */
    @Override
    public int getPhase() {
        // 默认为0
        return 0;
    }

    /**
     * 根据该方法的返回值决定是否执行start方法。<br/> 
     * 返回true时start方法会被自动执行，返回false则不会。
     */
    @Override
    public boolean isAutoStartup() {
        // 默认为false
        return true;
    }

    /**
     * 1. 只有该方法返回false时，start方法才会被执行。<br/>
     * 2. 只有该方法返回true时，stop(Runnable callback)或stop()方法才会被执行。
     */
    @Override
    public boolean isRunning() {
        // 默认返回false
        return isRunning;
    }

    /**
     * SmartLifecycle子类的才有的方法，当isRunning方法返回true时，该方法才会被调用。
     */
    @Override
    public void stop(Runnable callback) {
        System.out.println("stop(Runnable)");

        // 如果你让isRunning返回true，需要执行stop这个方法，那么就不要忘记调用callback.run()。
        // 否则在你程序退出时，Spring的DefaultLifecycleProcessor会认为你这个TestSmartLifecycle没有stop完成，程序会一直卡着结束不了，等待一定时间（默认超时时间30秒）后才会自动结束。
        // PS：如果你想修改这个默认超时时间，可以按下面思路做，当然下面代码是springmvc配置文件形式的参考，在SpringBoot中自然不是配置xml来完成，这里只是提供一种思路。
        // <bean id="lifecycleProcessor" class="org.springframework.context.support.DefaultLifecycleProcessor">
        //      <!-- timeout value in milliseconds -->
        //      <property name="timeoutPerShutdownPhase" value="10000"/>
        // </bean>
        callback.run();

        isRunning = false;
    }

    /**
     * 接口Lifecycle的子类的方法，只有非SmartLifecycle的子类才会执行该方法。<br/>
     * 1. 该方法只对直接实现接口Lifecycle的类才起作用，对实现SmartLifecycle接口的类无效。<br/>
     * 2. 方法stop()和方法stop(Runnable callback)的区别只在于，后者是SmartLifecycle子类的专属。
     */
    @Override
    public void stop() {
        System.out.println("stop");

        isRunning = false;
    }

}


```

**shutting down the Spring IoC container gracefully in non-web-applications	在非web应用程序中优雅的关闭spring IoC容器**

如果在非web应用程序环境中，，向jvm注册一个shoutdown hook。这样做可以确保优雅的关闭并调用单例bean上的相关destory方法，从而释放所有资源。但仍然必须正确的配置和实现这些销毁回调。

要注册一个shotdown hook，调用`configurableApplicationContext`接口上声明的`registershutdown hook()`方法。

```java
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public final class Boot {

    public static void main(final String[] args) throws Exception {
        ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");

        // add a shutdown hook for the above context...
        ctx.registerShutdownHook();

        // app runs here...

        // main method exits, hook is called prior to the app shutting down...
    }
}
```

##### 1.6.2	ApplicationContextAware and BeanNameAware

> BeanNameAware:实现该接口的Bean能够在初始化时知道自己在BeanFactory中对应的名字。
>
> BeanFactoryAware:实现该接口的Bean能够在初始化时知道自己所在的BeanFactory的名字
>
> ApplicationContextAware:实现该接口的对象能够在初始化时获取所在容器的容器对象本身。
>
> https://juejin.cn/post/6844904001964621832

当`applicationContext`创建一个实现`org.springframework.context.applicationContextAware`的对象实例时。在applicationContextAware接口中，实例提供了对该applicationContext的引用。

```java
public interface ApplicationContextAware {

    void setApplicationContext(ApplicationContext applicationContext) throws BeansException;
}

if (bean instanceof ApplicationContextAware) {
  		((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);
}
```

因此，bean可以通过applicationContext接口，或者通过将引用强制转换为该接口的已知子类(例如：ConfigurationApplicationContext，它公开了额外的功能)，以编程方式操作创建它们的ApplicationContext。其中一个用途是以编程方式检索其他bean。有时这种能力是有用的。但通常情况下应该避免它，因为它将代码与spring绑定在一起，而不是遵循控制反转风格。

自动装配时获取`ApplicationContext`的另一种选择。传统的构造函数和byType自动连接模式(如：自动连接协作者中所述)可以分别为构造函数参数或setter方法参数提供`ApplicatonContext`类型的依赖项。为了获得更大的灵活性，包括自动连接字段和多参数方法的能力，请使用基于注释的自动连接特性。如果按照此方式，ApplicationContext就会自动连接到需要使用ApplicationContext类型的字段，构造函数参数或方法参数中。

当`ApplicationContext`创建一个实现`org.springframework.beans.factory.BeanNameAware`接口的类时，BeanNameAware接口中，该类提供了对其关联对象定义中定义的名称的引用。

```java
public interface BeanNameAware {

    void setBeanName(String name) throws BeansException;
}

if (bean instanceof BeanNameAware){
  	((BeanNameAware) bean).setBeanName(BeanName);
}
```

在填充正常的bean属性之后但在初始化回调（例如InitializingBean，afterPropertiesSet或自定义init-method）之前调用该回调。

##### 1.6.3	other Aware	interfaces

除了 ApplicationContextAware 和 BeanNameAware (前面讨论过)之外，Spring 还提供了广泛的 Aware 回调接口，允许 bean 向容器指示它们需要某种基础结构依赖项。作为一般规则，名称表示依赖类型。下表总结了最重要的 Aware 接口:

| **name**                       | **injected dependency**                                      | explained in...                                        |
| ------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------ |
| ApplicationContextAware        | Declaring `ApplicationContext`                               | ApplicationContextAware and BeanNameAware              |
| ApplicationEventPublisherAware | event publisher of the enclosing `ApplicationContext`        | Additional capabilities of the ApplicationContext      |
| BeanClassLoaderAware           | Class loader used to load the bean classes                   | Instantiiating beans                                   |
| BeanFactoryAware               | Declaring `BeanFactory`                                      | ApplicationContextAware and BeanNameAware              |
| BeanNameAware                  | Name of the declaring bean                                   | ApplicationContextAware and BeanNameAware              |
| LoadTimeWeaverAware            | Defined weaver for processing class definition at load time  | Load-time Weaving with AspectJ in the spring framework |
| MessageSourceAware             | Configured strategy for resolving messages (with support for parametrization and internationalization) | Additional Capabilities of the ApplicationContext      |
| NotificationPublisherAware     | Spring JMX notification publisher                            | Notifications                                          |
| ResourceLoaderAware            | Configured loader for low=level access to resources          | Resources                                              |
| ServletConfigAware             | current `servletConfig` the container runs in.valid only in a web-aware spring `applicationContext` | spring mvc                                             |
| ServletContextAware            | current `servletConfig` the container runs in.valid only in a web-aware spring `applicationContext` | spring mvc                                             |

需要注意的是，这些接口将代码与spring API绑定在一起，而不是遵循控制反转应用程序风格。因此对于需要对容器进行编程访问的基础结构bean，建议使用这些方法。

#### 1.7	Bean Definition Inheritance	bean定义继承

> 子类定义和父类定义在实现类上，并没有继承关系。所谓的定义继承指的是继承了父类定义，即：int a = 10；则子类定义的a就是10。

Bean定义可以包含许多配置信息，包括构造函数参数、属性和特定于容器的信息，例如初始化方法，静态工厂方法名称等。子bean定义 从父bean定义 继承配置数据，自定义可以覆盖某些值或根据需要添加其他值。使用父bean和子bean定义可以节省很多输入。实际上这是一种模版模式。

```xml
<bean id="inheritedTestBean" abstract="true"
        class="org.springframework.beans.TestBean">
    <property name="name" value="parent"/>
    <property name="age" value="1"/>
</bean>

<bean id="inheritsWithDifferentClass"
        class="org.springframework.beans.DerivedTestBean"
        parent="inheritedTestBean" init-method="initialize">  
    <property name="name" value="override"/>
    <!-- the age property value of 1 will be inherited from parent -->
</bean>
```

通过<bean/>标签内的`parent`属性，指定了定义的继承关系，子类定义就继承了父类的`<property name="age" value="1"/>`这行配置数据。

子bean定义从父类继承范围、构造函数参数值、属性值和方法重写，并带有添加新值的选项。指定的任何范围、初始化方法、销毁方法或静态工厂方法设置都将重写相应的父设置。其余的设置总是从自定义中获取：depends、autowire模式、dependency check、singleton 和lazy init。

前面的示例使用abstract属性将父bean定义显示标记为abstract。如果父定义没有指定类，则需要显式地将父bean定义标记为abstract。

```xml
<bean id="inheritedTestBeanWithoutClass" abstract="true">
    <property name="name" value="parent"/>
    <property name="age" value="1"/>
</bean>

<bean id="inheritsWithClass" class="org.springframework.beans.DerivedTestBean"
        parent="inheritedTestBeanWithoutClass" init-method="initialize">
    <property name="name" value="override"/>
    <!-- age will inherit the value of 1 from the parent bean definition-->
</bean>
```

父bean不能自己实例化，因为它是不完整的，并且显式地标记为抽象的。当定义是抽象的时候，它只能作为纯模版bean定义使用，纯模版bean定义作为子定义的父定义。尝试单独使用这样的抽象父bean，通过将其引用为另一个bean的ref属性或使用父bean ID执行显式的getBean()调用，将返回一个错误。类似的，容器的内部preinstanceatesingletons()方法忽略定义为抽象的bean定义。

> 默认情况下，`ApplicationContext`会预先实例化所有单例。因此，重要的是(至少对于单例bean)，如果有一个(父)bean定义仅打算当作纯模版，并且此定义指定了一个类，则必须确保将abstract属性设置为true，否则 应用程序上下文将实际上(试图)预先实例化抽象bean。

#### 1.8 container extension points	容器后置处理器

<img src="../../../../../../Library/Application%20Support/typora-user-images/image-20210114144218588.png" alt="image-20210114144218588" style="zoom:50%;" />

> [源码解读](https://blog.csdn.net/caihaijiang/article/details/35552859)
>
> [beanfactory.getBean()方法解析](https://blog.csdn.net/zghwaicsdn/article/details/50910384)

##### 1.8.1 customizing beans by using

`BeanPostProcessor`接口定义了回调方法，可以实现这些回调方法，以提供自己的(或覆盖容器的默认值)是 实例化逻辑，依赖项解析逻辑等。如果想在spring完成实例化，配置和初始化bean之后实现一些自定义逻辑，则可以插入一个或多个自定义`BeanPostProcessor`实现。

可以配置多个`BeanPostProcessor`实例，并且可以通过设置order属性来控制这些BeanPostProcessor实例的运行顺序，只有当BeanPostProcessor实现ordered接口时，才能设置此属性。如果自己编写BeanPostProcessor，那么也应该考虑实现ordered接口。

> BeanPostProcessor在初始化前后调用方法，BeanPostProcessor的作用范围是所在的容器，只对所在容器内的bean生效。
>
>  通常，通过实现BeanPostProcessor的postProcessBeforeInitialization方法（配合标记接口，如@Autowired）来填充bean实例，
>  通过BeanPostProcessor的postProcessAfterInitialization方法进行bean实例的代理

`Springframework.beans.factory.config.BeanPostProcessor`接口由两个方法构成，当一个类注册为容器的后处理器时，对于容器创建的每个bean实例，后处理器在调用容器初始化方法(如：InitializingBean.afterPropertiesSet()或任何声明的init方法)之前和任何bean初始化回调之后都会从容器获得一个回调。ApplicationContext自动检测任何在配置元数据中定义的实现BeanPostProcessor接口的bean，ApplicationContext将这些bean注册成为后处理器，在稍后创建bean时/对于lazy-init的singleton的bean和prototype的bean是在调用beanfactory.getBean()方法时，调用回调方法。bean后处理器可以像其他bena一样部署在容器中。

注意，在配置类上使用@bean 通过factory method的形式声明BeanPostProcessor时，factory method 的返回类型应该是实现类本身或者`BeanPostProcessor`接口，需要清楚的表明了bean的后处理特性。否则ApplicationContext无法在完全创建它之前通过类型自动检测它。

```java
//容器初始化时通过类型搜索的方式，自动检测所有 
String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);
```

> 以编程方式注册BeanPostProcessor实例
>
> 尽管建议的BeanPostProcessor注册方法是通过ApplicationContext自动检测，但是可以使用ConfigurableBeanFactory的addBeanPostProcessor方法来注册它们。当您需要在注册之前评估条件逻辑，甚至需要跨层次结构的上下文复制Bean后处理器时，这将非常有用。
>
> 但是，以编程方式添加的BeanPostProcessor实例不遵守Ordered接口，在这里注册的顺序决定了执行的顺序。而且以编程方式注册的BeanPostProcessor实例始终在通过自动检测注册的实例之前进行处理，而不考虑任何明确的顺序。

> BeanPostProcessor实例和AOP自动代理(由于aop是通过实现BeanPostProcessor接口来完成功能的，因此BeanPostProcessor的实例都无法再被AOP代理)
>
> 实现BeanPostProcessor接口的类时独特的，容器对它们采取不同的处理方式。作为ApplicationContext特殊启动阶段的一部分，所有BeanPostProcessor实例和它们直接引用的bean都会在启动时实例化。接下来，以排列方式注册所有BeanPostProcessor实例，并将其应用于容器中的所有其他bean。因为AOP自动代理是作为BeanPostProcessor本身实现的，所以BeanPostProcessor实例或它们直接引用的bean都没有资格进行自动代理，因为没有切面。
>
> 对于任何此类bean，会看到一条信息日志消息：Bean someBean不适合所有BeanPostProcessor接口进行处理。
>
> 如果使用自动装配或@Resource(可能会退回到自动装配)将Bean连接到BeanPostProcessor中，则Spring在搜索类型匹配的依赖项候选对象时可能会访问意外的bean，因此使它们不符合自动代理或其他种类的bean post-processing。例如：如果有一个@Resource注释的依赖项，其中字段或setter名称不直接与bean的声明名称相对应，并且不使用name属性，那么spring将访问其他bean以按类型匹配它们。

结合自定义BeanPostProcessor实例去实现回调接口或注释 是拓展Spring IoC容器的常见方法。一个例子是Spring的RequiredAnnotationBeanPostProcessor--它可以确保使用（任意）批注标记的bean上的JavaBean属性实际上（配置为）依赖注入了一个值。

##### 1.8.2 Customizing Configuration Metadata with a `BeanfactoryPostProcessor`

>[使用BeanFactoryPostProcessor实现配置信息加密处理](https://www.cnblogs.com/youzhibing/p/10559337.html)

`org.springframework.beans.factory.config.BeanFactoryPostProcessor`。这个接口的语义类似于`BeanPostProcessor`，但有一个主要区别：`BeanPostProcessor`对bean配置元数据进行操作。也就是说，spring IoC容器允许`BeanFactoryPostProcessor`在容器实例化(除了BeanFactoryPostProcessor实例)的任何bean之前读取配置元数据并可能更改它。

可以配置多个`BeanFactoryPostProcessor`实例，并且通过设置order属性来控制这些`BeanFactoryPostProcessor`实例的执行顺序，`BeanFactoryPostProcessor`实例必须实现`Ordered`接口。

> 如果想要更改实际的bean实例(从配置元数据创建的对象)，那么需要使用BeanPostProcessor(上节描述过)。虽然在技术上可以在`BeanFactoryPostProcessor`中使用bean实例(例如，使用BeanFactory.getBean() )，但是这样做会导致bean提前实例化，从而违反标准容器生命周期，可能会导致负面的副作用，例如绕过bean的post processor [BeanFactoryPostProcessor提前实例化导致错误](https://www.jianshu.com/p/3d099ea43b0e)
>
> 此外，BeanFactoryPostProcessor实例的作用域为每个容器，只有在使用容器层次结构时，这才是相关的。如果在一个容器中定义`BeanFactoryPostProcessor`，则它只应用于该容器中的bean定义。一个容器中的bean定义不会由另一个容器中的`BeanFactoryPostProcessor`实例进行post processor，即使两个容器都属于同一层次结构。

bean工厂后处理器在ApplicationContext中声明时自动运行，以便对定义容器的配置元数据应用进行更改。Spring拥有许多提前定义好的bean工厂后处理器，例如PropertyOverrideConfigurer和propertysourceplaceholderconfigureer。还可以使用自定义`BeanFactoryPostProcessor`，例如注册自定义属性编辑器。

ApplicationContext自动检测部署到其中的实现`BeanFactoryPostProcessor`接口的任何bean。它在适当的时候使用这些bean作为bean factory的后处理器。可以像(deploy)部署其他bean一样部署这些后处理bean。

>与BeanPostProcessors一样，您通常不想为延迟初始化配置BeanFactoryPostProcessors。 如果没有其他bean引用Bean（Factory）PostProcessor，则该后处理器将完全不会被实例化。 因此，将其标记为延迟初始化将被忽略，即使您在<beans/>元素的声明中将default-lazy-init属性设置为true，Bean（Factory）PostProcessor也会被实例化。
>
> [Can Spring init Bean(Factory)PostProcessor lazily?](https://stackoverflow.com/questions/53267404/can-spring-init-beanfactorypostprocessor-lazily)

##### 1.8.3 Customizing Instantiation Logic with a `FactoryBean`

可以为本身就是工厂的对象实现`org.springframework.beans.factory.FactoryBean`接口。

`FactoryBean`接口是Spring IoC容器的实例化逻辑的插入点。如果您有复杂的初始化代码，而用Java更好地表达了该代码（而不是冗长的XML），则可以创建自己的FactoryBean，在该类中编写复杂的初始化，然后将自定义FactoryBean插入容器中

`FactoryBean`接口提供了三种方法：

+ `Object getObject()`：返回此工厂创建的对象的实例。实例可以共享，这取决于该工厂返回的是singletons 还是 prototypes。
+ `boolean isSingleton()`：如果这个`FactoryBean` 是singletons 则返回true，否则返回false
+ `Class getObjectType()`：返回getObject()方法返回的对象类型，如果事先不知道类型，返回null。

`FactoryBean`接口和概念在spring框架中的许多地方都有使用。spring本身附带了50多个`FactoryBean`接口的实现。

当需要向容器请求一个实际的FactoryBean实例本身而不是它生成bean时，在调用ApplicationContext的getBean()方法时，在bean的id前面加上&符号。

#### 1.9 Annotation-based Container Configuration 基于注释的容器配置

>**注解和xml，哪种方式更好**
>
>注释在其生命中提供了大量上下文，从而使配置更简洁。
>
>XML擅长将组件连接起来而不触及它们的源代码或重新编译它们。

基于注释的配置提供了XML设置的一种替代方法，它依赖于字节码元数据来连接组件，而不是<>声明。

注释注入在xml注入之前执行。因此xml配置覆盖了通过这两种方法连接的属性的注释。

可以将它们注册为单独的bean定义，但也可以通过在基于xml的spring配置中包含一下标记来隐式的注册它们。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config/>

</beans>
```

(隐式注册的后处理器包括 AutowiredAnnotationBeanPostProcessor、 CommonAnnotationBeanPostProcessor、 PersistenceAnnotationBeanPostProcessor 和前面提到的 RequiredAnnotationBeanPostProcessor.)

> < context: annotation-config/> 只在它所在 bean定义 的应用程序上下文中 查找 bean 上的注释。这意味着，如果将 < context: annotation-config/> 放在针对 DispatcherServlet 的 WebApplicationContext 中，它只检查控制器中的@autowired 的 bean，而不检查服务。

##### 1.9.1 @required

`@required`注释应用于bean属性setter方法。

```java
public class SimpleMovieLister{
  
		private MovieFinder movieFinder;
	
  	@Required
		public void setMovieFinder(MovieFinder movieFinder){
				this.movieFinder = movieFinder;
		}
		
		//......
}
```

这个注释表明：受影响的bean属性必须在配置时通过bean定义中的显式属性值或通过自动配置来填充。如果为填充受影响的bean属性，则容器将抛出异常。这导致显式的失败，从而抛出NullPointException或类似的情况。

从SpringFramework 5.1开始，`@required`注释就被证实废弃了，这有利于为所需的设置(或initializingBean.afterPropertiesSer()的自定义实现以及bean属性setter方法)使用构造函数注入。

##### 1.9.2 Using `@Autowired`

> 可以使用JSR330的`@Inject`注释来代替本节中包含的实例中的spring`@Autowired`注释。
>
> 详细：https://blog.csdn.net/f641385712/article/details/88410362

1.可以对构造函数使用`@Autowired`注释。

```java
public class MovieRecommender {

    private final CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}
```

> 从Spring Framework 4.3开始，如果目标bean从一开始就只定义一个构造函数，那么在这样的构造函数上就不再需要@autowired注释了。但是，如果有多个构造函数可用，而且没有primary/dafault构造函数，那么至少其中一个构造函数必须注释为@autowired，以便指示容器使用哪个构造函数。

2.可以对传统的setter应用@Autowired注释

```java
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Autowired
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
```

3.可以将注释应用于具有任意名称和多个参数的方法

```java
public class MovieRecommender {

    private MovieCatalog movieCatalog;

    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public void prepare(MovieCatalog movieCatalog,
            CustomerPreferenceDao customerPreferenceDao) {
        this.movieCatalog = movieCatalog;
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}
```

4.将@autowired应用到字段，与构造函数混合使用

```java
public class MovieRecommender {

    private final CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    private MovieCatalog movieCatalog;

    @Autowired
    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}
```

>//todo	没搞懂什么意思，大概：通过上下文getBean获得bean A，A里面有变量通过@Autowired自动注入，报错。
>
>确保您的目标组件(例如 MovieCatalog 或 CustomerPreferenceDao)一致地由您用于@autowired 注释注入点的类型声明。否则，注入可能会失败，原因是在运行时出现“未找到类型匹配”错误。
>
>对于通过类路径扫描找到的 xml 定义的 bean 或组件类，容器通常事先知道具体类型。但是，对于@bean factory 方法，您需要确保声明的返回类型具有足够的表达能力。对于实现多个接口的组件或者可能由其实现类型引用的组件，可以考虑在工厂方法中声明最具体的返回类型(至少与引用 bean 的注入点所要求的具体类型一样)。
>
>//todo

5.可以指示spring从ApplicationContext中提供所有特定类型的bean，方法时将@autowired注释添加到需要该类型数组的字段或方法中。

```java
public class MovieRecommender {

    @Autowired
    private MovieCatalog[] movieCatalogs;
		//返回所有的MovieCatalog
    // ...
}
```

6.类型化集合也是如此

```java
public class MovieRecommender {

    private Set<MovieCatalog> movieCatalogs;

    @Autowired
    public void setMovieCatalogs(Set<MovieCatalog> movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }

    // ...
}
```

> 目标bean可以实现`org.springframework.core.Ordered`接口或者使用`@Order`或者标准的`@Priority`，否则它们的顺序遵循容器中相应的目标bean定义的注册顺序。

7.只要预期的键类型是String，即使类型化的Map实例也可以自动连接。Map值包含所有预期类型的bean，key包含相应的bean 名称：

```java
public class MovieRecommender {

    private Map<String, MovieCatalog> movieCatalogs;

    @Autowired
    public void setMovieCatalogs(Map<String, MovieCatalog> movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }

    // ...
}
```

默认情况下，对于声明的数组、集合或映射，至少需要一个匹配的元素，如果给定注入点没有匹配的候选bean时，autowiring失败。

默认行为时将注释的方法和字段视为指示必须的依赖项。可以修改这个行为，通过框架标记为on-required(也就是将@autowired的required属性设置为false)，如下所示：

```java
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Autowired(required = false)
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
```

如果一个(on-required)非必需的方法的依赖项(或者它的一个依赖项，在多个参数的情况下)不可用，那么它就根本不会被调用。在这种情况下，根本不会填充非必需字段，保留其默认值。

注入的构造函数和工厂方法参数时一个特例，因为在@Autowired中需要的属性由于spring的构造函数解析算法可能会处理多个构造函数而具有不同的含义。在特殊情况下，构造函数和工厂方法参数实际上是必须的，但是在单构造函数场景中有一些特殊规则，例如：如果没有匹配的bean可用，多元素注入点(数组、集合、映射)将解析为空实例。这允许一种通用的实现模式，其中所有依赖项都可以在一个唯一的多参数构造函数中声明-例如声明为单个公共构造函数，而不需要@autowired注释。

> 任何给定bean类只有一个构造函数可以将`@Autowired`的`required`属性设置为true，作为spring bean使用时指示该构造函数使用autowired。如果`required`是默认值为true，那么只有一个构造函数可以用`@Autowired`。如果多个构造函数声明该注释，那么它们都必须声明required = false，将被视为可以进行autowiring (类似于xml中的autowire = constructor)的候选对象。通过匹配Spring容器中的bean可以满足的依赖项数量最多的构造函数将被选择使用。 如果没有一个候选者满足，那么将使用 primary/default 构造函数（如果存在）。 同样，如果一个类声明了多个构造函数，但都没有使用@Autowired进行注释，则将使用 primary/default 构造函数（如果存在）。 如果一个类仅声明一个单一的构造函数开始，即使没有注释，也将始终使用它。 请注意，带注释的构造函数不必是public
>
> 推荐使用@autowired的必须属性，而不推荐使用setter方法上已启用的@required注释。将required属性设置为false表示该属性对于autowiring 不是必须的。如果不能autowiring，则忽略该属性。@Required更健壮，因为它强制容器通过任何支持的方式设置属性，如果没有定义值，就会引发异常。

在spring framework5.0中可以使用@nullable注释，来自JSR-305的`javax.annotation.Nullable`，或仅仅利用Kotlin内置的null安全支持。

```java
public class SimpleMovieLister {

    @Autowired
    public void setMovieFinder(@Nullable MovieFinder movieFinder) {
        ...
    }
}
```

对于中所周知的课解析依赖项：BeanFactory、ApplicationContext、Environment、ResourceLoader、ApplicationEventPublisher和MessageSource，还可以使用@autowired。这些接口及其拓展接口(例如：ConfigurableApplicationContext、ResourcePatternResolver)可以自动解析，不需要特殊设置。

```java
public class MovieRecommender {

    @Autowired
    private ApplicationContext context;

    public MovieRecommender() {
    }

    // ...
}
```

> @autowired、@inject、@value和@resource注释由Spring BeanPostProcessor实现处理。这意味着您不能在自己的BeanPostProcessor或BeanFactoryPostProcessor类型中应用这些注释。这些类型必须通过使用xml或者spring @Bean方法显式的"连接"起来

##### 1.9.3 Fine-tuning Annotation-based Autowiring with `@Primary`

因为按类型autowiring可能会导致存在多个候选人，所以通常需要多选择过程由更多的控制。实现这一点的一种方式就是使用Spring的`@Primary`注释，它表示：当多个bean自动连接到单值依赖项时，应该优先选择特定的bean。如果后选项中有一个是primary bean，那么它就成为了autowired值。

```java
@Configuration
public class MovieConfiguration {

    @Bean
    @Primary
    public MovieCatalog firstMovieCatalog() { ... }

    @Bean
    public MovieCatalog secondMovieCatalog() { ... }

    // ...
}
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config/>

    <bean class="example.SimpleMovieCatalog" primary="true">
        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean class="example.SimpleMovieCatalog">
        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean id="movieRecommender" class="example.MovieRecommender"/>

</beans>
```

##### 1.9.4 fine-tuning annotation-based autowiring with qualifiers

> 同时存在primary与qualifier且发生冲突时，优先根据qualifier规则执行。

`@primary`在通过类型寻找到多个实例进行自动注入的时候确定主候选方案的一个方法。当需要对选择过程进行更多控制时，可以使用Spring的@qualifer注释。可以将限定符值于特定参数关联起来，从而缩小类型匹配的范围，以便为每个参数选择特定的bean。

```java
public class MovieRecommender {

    @Autowired
    @Qualifier("main")
    private MovieCatalog movieCatalog;

    // ...
}

public class MovieRecommender {

    private MovieCatalog movieCatalog;

    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public void prepare(@Qualifier("main") MovieCatalog movieCatalog,
            CustomerPreferenceDao customerPreferenceDao) {
        this.movieCatalog = movieCatalog;
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config/>

    <bean class="example.SimpleMovieCatalog">
        <qualifier value="main"/> 

        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean class="example.SimpleMovieCatalog">
        <qualifier value="action"/> 

        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean id="movieRecommender" class="example.MovieRecommender"/>

</beans>
```

对于回退匹配(fallback match)，bean名称被视为默认限定符值。因此可以用main的id而不是嵌套限定符元素来定义bean。尽管可以使用这个约定通过名称引用特定的bean，但是@autowired从根本上讲时关于带有可选语义限定符的类型驱动的注入，这意味着限定符(即使使用bean名称 fallback)在类型匹配集合中始终具有收缩语义。它们在语义上不表示对唯一bean id的引用。良好的限定符值时main、emea和persistent，表示独立于bean id的特定组件的特征，在匿名bean定义(如前面示例中的定义)的情况下，可以自动生成这些特征。

限定符也适用于类型化集合。如前面所讨论的：例如 Set<moviecatalog>。在这种情况下，根据声明的限定符，所有匹配的bean都被注入为一个集合。这意味着限定符不必时唯一的。相反，它们构成了过滤标准。例如：可以使用相同的"action"定义多个MovieCatalog bean，所有这些bean都被注入到带有@qualifier("action")注释的Set<MovieCatalog>中

> 让限定符值在类型匹配候选对象中根据目标bean名称进行选择，不需要在注入点使用@qualifier注释。如果没有其他解析指示器(比如限定符或主标记)，对于非唯一依赖情况，spring将针对目标bean名匹配注入点名称(即字段名或参数名)，并选择名称相同的候选项(如果有的话)

也就是说，如果你想通过名字来表达注释驱动的注入，不要主动使用@autowired，即使它能够在类型匹配的候选对象中通过bean名字进行选择。相反，应该使用JSR-250 @Resource注释，这个注释在语义上定义为根据特定的目标组件的唯一名称标识该组件，声明的类型与匹配过程无关。@autowired有相当不同的语义：在按照类型选择候选bean之后，指定的String限定符值仅在这些类型选择的候选者中被考虑

对于本身被定义为集合、Map或数组类型的bean，@Resource是一个很好的解决方案，通过唯一名称饮用特定的集合或数组bean。也就是说，从4.3版本开始，只要元素类型信息保留在@Bean返回类型签名或集合继承层次结构中，就可以通过Spring的@Autowired类型匹配算法来匹配Map和数组类型。 在这种情况下，您可以使用限定符值在同类型的集合中进行选择，如上一段所述。

从4.3开始，@ Autowired还考虑了自我引用以进行注入（即，引用回当前注入的Bean）。 请注意，自我注入是一个fallback。 对其他组件的常规依赖始终优先。 从这个意义上说，自我推荐不参与常规的候选人选择，因此尤其是从不重要。 相反，它们总是以最低优先级结束。 实际上，您应该仅将自我引用用作最后的手段（例如，通过Bean的事务代理在同一实例上调用其他方法）。 在这种情况下，请考虑将受影响的方法分解为单独的委托Bean。 或者，您可以使用@Resource，它可以通过其唯一名称获取返回到当前bean的代理。

> 尝试将@Bean方法的结果注入相同的配置类也实际上是一种自引用方案。 要么在实际需要的方法签名中 lazy 地解析此类引用（与配置类中的自动装配字段相对），要么将受影响的@Bean方法声明为静态，将其与包含的配置类实例及其生命周期脱钩。 否则，仅在回退阶段考虑此类Bean，而将其他配置类上的匹配Bean选作主要候选对象（如果可用）。

@Autowired适用于字段、构造函数和多参数方法，允许在参数级通过qualifier注释进行收缩。相比之下，@Resource仅支持字段和bean属性setter方法，并且只有一个参数。因此，如果注入目标是构造函数或多参数方法，则应该坚持使用限定符。

可以创建自己的自定义限定符注释。为此，定义一个注释并在定义中提供@qualifier注释。

```java
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Genre {

    String value();
}


public class MovieRecommender {

    @Autowired
    @Genre("Action")
    private MovieCatalog actionCatalog;

    private MovieCatalog comedyCatalog;

    @Autowired
    public void setComedyCatalog(@Genre("Comedy") MovieCatalog comedyCatalog) {
        this.comedyCatalog = comedyCatalog;
    }

    // ...
}
```

接下来可以提供候选bean定义的信息，添加<qualifier/>标记作为<bean/>标记的字元素。然后指定类型和值来匹配自定义的qualifier注释。类型和注释的完全限定类名匹配，为了方便起见，如果不存在名称冲突的风险，可以使用短类名。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config/>

    <bean class="example.SimpleMovieCatalog">
        <qualifier type="Genre" value="Action"/>
        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean class="example.SimpleMovieCatalog">
        <qualifier type="example.Genre" value="Comedy"/>
        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean id="movieRecommender" class="example.MovieRecommender"/>

</beans>
```

##### 1.9.5 using generics as autowiring qualifiers

除了@qualifier注释外，还可以使用java泛型类型作为一种隐式的限定形式。

```java
@Configuration
public class MyConfiguration {

    @Bean
    public StringStore stringStore() {
        return new StringStore();
    }

    @Bean
    public IntegerStore integerStore() {
        return new IntegerStore();
    }
}

```

假设前面的bean实现了一个通用接口(即 Store<string> 和 Store<Integer> )，可以@autowire 在store接口，通用接口用做限定符：

```java
@Autowired
private Store<String> s1; // <String> qualifier, injects the stringStore bean

@Autowired
private Store<Integer> s2; // <Integer> qualifier, injects the integerStore bean

// Inject all Store beans as long as they have an <Integer> generic
// Store<String> beans will not appear in this list
@Autowired
private List<Store<Integer>> s;
```



##### 1.9.6 using `CustomAutowireConfigurer`

`CustomAutowireConfigurer`是一个`BeanFactoryPostProcessor`，它允许注册自己的自定义限定符注释类型，即使它们没有注释spring的@qualifier注释：

```xml
<bean id="customAutowireConfigurer"
        class="org.springframework.beans.factory.annotation.CustomAutowireConfigurer">
    <property name="customQualifierTypes">
        <set>
            <value>example.CustomQualifier</value>
        </set>
    </property>
</bean>

```

`AutowireCandidateResolver`通过一下方式确认候选者:

+ 每个bean定义的`autowire-candidate`值
+ 在<beans/>元素上可用的任何`default-autowire-candidates`模式
+ `@Qualifier`注释和任何向`CustomAutowireConfigurer`注册的自定义注释

当多个bean符合autowire候选项时，如果后选项中只有一个bean定义的`primary`属性设置为true，则选择该bean。

##### 1.9.7 injection with `@Resource`

spring通过使用jsr-250的@Resource注释支持：字段，setter方法注入。

@resource采取名称属性，默认情况下，spring将该值解释为要注入的bean名称。也就是说它遵循名称语义。

```java
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Resource(name="myMovieFinder") 
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}
```

如果未显式指定名称，则从字段名称或setter方法派生默认名称。

```java
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Resource
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}
```

> 注释提供的名称由CommonAnnotationBeanPostProcessor所在的ApplicationContext解析为bean名称。 如果您明确配置Spring的SimpleJndiBeanFactory，则可以通过JNDI解析名称。 但是，我们建议您依赖默认行为，并使用Spring的JNDI查找功能来保留间接级别。

在没有指定明确名称的@resource使用的独占情况下，与@autowired类似，@resource查找primary 类型匹配而不是特定的命名bean，并解析众所周知的可解析依赖项：BeanFactory、ApplicationContext、ResourceLoader、ApplicationEventPublisher和MessageSource接口

因此在下面示例中，customerPreferenceDao字段首先查找名为"customerPreferenceDao"的bean，然后返回到customerPreferenceDao类型的主类型匹配：

```java
public class MovieRecommender {

    @Resource
    private CustomerPreferenceDao customerPreferenceDao;

    @Resource
    private ApplicationContext context; 

    public MovieRecommender() {
    }

    // ...
}
```

##### 1.9.8 using @value

@value通常用于注入外部化属性

```java
@Component
public class MovieRecommender {

    private final String catalog;

    public MovieRecommender(@Value("${catalog.name}") String catalog) {
        this.catalog = catalog;
    }
}
```

在配置文件中配置catalog.name的值

spring提供了一个磨人的宽大的嵌入值解析器。它将尝试解析属性值，如果无法解析，则将注入属性名(例如`${catalog.name}`)作为值。如果你想对不存在的值保持严格的控制，应该声明一个`PropertySourcesPlaceholderConfigurer` bean。

```java
@Configuration
public class AppConfig {

     @Bean
     public static PropertySourcesPlaceholderConfigurer propertyPlaceholderConfigurer() {
           return new PropertySourcesPlaceholderConfigurer();
     }
}
```

当使用javaConfig配置`PropertySourcesPlaceholderConfigurer`的时候，@bean方法必须是static。

无果无法解析任何${}占位符，使用上述配置将确保spring初始化失败，还可以使用setPlaceholderPrefix、setPlaceholderSuffix或setValueSeparator等方法来自定义占位符。

> SpringBoot默认配置一个PropertySourcesPlaceholderConfigurer bean，它将从application.properties和application.yml文件中获取属性。

spring提供的内置转换器支持允许自动处理简单的类型转换(例如Integer到int)。多个都好分隔值可以自动转换为字符串数组而不需要额外的努力。

也可以提供默认值：

```java
@Component
public class MovieRecommender {

    private final String catalog;

    public MovieRecommender(@Value("${catalog.name:defaultCatalog}") String catalog) {
        this.catalog = catalog;
    }
}
```

Spring BeanPostProcessor在后台使用ConversionService处理将@Value中的String值转换为目标类型的过程。 如果要为自己的自定义类型提供转换支持，则可以提供自己的ConversionService bean实例，如以下示例所示：`

```java
@Configuration
public class AppConfig {

    @Bean
    public ConversionService conversionService() {
        DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService();
        conversionService.addConverter(new MyCustomConverter());
        return conversionService;
    }
}
```

当@value包含一个spel表达式时，该值将在运行时动态计算。spel还支持更复杂的数据结构。

##### 1.9.9 using @PostConstruct and @PreDestory

`CommonAnnotationBeanPostProcessor`不仅识别@Resource注释还识别jsr-250生命周期的注释：`javax.annotation.PostConstruct`和`javax.annotation.PreDestory`。在Spring 2.5中引入的对这些注释的支持为初始化回调和销毁回调中描述的生命周期回调机制提供了替代方法。如果`CommonAnnotationBeanPostProcessor`在Spring `ApplicationContext`中注册，则在生命周期中与相应的Spring生命周期接口方法或显式声明的回调方法在同一点调用带有这些注释之一的方法。 在以下示例中，缓存在初始化时预先填充，并在销毁时清除：

```java
public class CachingMovieLister {

    @PostConstruct
    public void populateMovieCache() {
        // populates the movie cache upon initialization...
    }

    @PreDestroy
    public void clearMovieCache() {
        // clears the movie cache upon destruction...
    }
}
```

> 像@Resource一样，从JDK6-8，@PostConstruct和@PreDestory注释类型是标准java库的一部分，然而，整个`javax.annotation`包从jdk9的核心java模块中分离出来，并最终在jdk11中删除。如果需要，现在就需要通过maven central获取`javax.annotation-api`构件，只需将其像其他库一样添加到应用程序的类路径中即可。

#### 1.10 Classpath Scanning and Managed Components

本章中的大多数示例都使用XML来指定在Spring容器中生成每个BeanDefinition的配置元数据。上一节（基于注释的容器配置）演示了如何通过源级别的注释提供许多配置元数据。 但是，即使在这些示例中，“基本” bean定义也已在XML文件中明确定义，而注释只是驱动了依赖项注入。 本节介绍了通过扫描类路径来隐式检测候选组件的选项。 候选组件是与过滤条件匹配的类，并具有在容器中注册的符合标准的bean定义。 这消除了使用XML进行bean注册的需要。 相反，您可以使用注释（例如，@ Component），AspectJ类型表达式或您自己的自定义过滤条件来选择哪些类已向容器注册了bean定义。

> 从 Spring 3.0开始，Spring JavaConfig 项目提供的许多特性都是核心 Spring 框架的一部分。这允许您使用 Java 而不是传统的 XML 文件来定义 bean。看看@configuration、@bean、@import 和@dependson 注释，了解如何使用这些新特性。

##### 1.10.1	`@Component` and Further Stereotype Annotations component和功能模版注解

`@Repository`注解是任何满足存储库 role或原型(也称为 Data Access Object或 DAO)的类的标记。

Spring提供了更多的原型注解：@Component、@Service和@Controller。@Component是任何spring管理的组件的通用构造型。@Repository、@Service和@Controller是各个专业化的@Component。

##### 1.10.2 using Meta-annotation and Composed Annotations

Spring提供的许多注解可以在代码中用作元注解。元注解是一个可以应用于另一个注解的注解。

可以组合元注解来创建组合注解：例如MVC中的@Restcontroller注解由@Controller和@Responsebody组成。

组合注解可以重新声明元注解的属性，来允许定制。例如：

```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Scope(WebApplicationContext.SCOPE_SESSION)
public @interface SessionScope {

    /**
     * Alias for {@link Scope#proxyMode}.
     * <p>Defaults to {@link ScopedProxyMode#TARGET_CLASS}.
     */
    @AliasFor(annotation = Scope.class)
    ScopedProxyMode proxyMode() default ScopedProxyMode.TARGET_CLASS;

}

@Service
@SessionScope
public class SessionScopedService {
    // ...
}

@Service
@SessionScope(proxyMode = ScopedProxyMode.INTERFACES)
public class SessionScopedUserService implements UserService {
    // ...
}
```

##### 1.10.3 Automatically Detecting Classes and Registering Bean Definitions

Spring可以自动检测构造型类，并向ApplicationContext注册相应的BeanDefinition实例。

要自动检测这些类并注册相应的 bean，需要将@componentscan 添加到@configuration 类中，其中 basePackages 属性是这两个类的通用父包。(或者，您可以指定一个逗号或分号或空格分隔的列表，其中包括每个类的父包。)

```java
@Configuration
@ComponentScan(basePackages = "org.example")
public class AppConfig  {
    // ...
}
```

```xml
<!-- xml配置	-->
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <context:component-scan base-package="org.example"/>

</beans>
```

> <context：component-scan>隐式启用<context：annotation-config>的功能。 使用<context：component-scan>时，通常无需包含<context：annotation-config>元素。 

>The scanning of classpath packages requires the presence of corresponding directory entries in the classpath. When you build JARs with Ant, make sure that you do not activate the files-only switch of the JAR task. Also, classpath directories may not be exposed based on security policies in some environments — for example, standalone apps on JDK 1.7.0_45 and higher (which requires 'Trusted-Library' setup in your manifests — see https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources).
>
>On JDK 9’s module path (Jigsaw), Spring’s classpath scanning generally works as expected. However, make sure that your component classes are exported in your `module-info` descriptors. If you expect Spring to invoke non-public members of your classes, make sure that they are 'opened' (that is, that they use an `opens` declaration instead of an `exports` declaration in your `module-info` descriptor).

此外，在使用 component-scan 元素时，AutowiredAnnotationBeanPostProcessor 和 CommonAnnotationBeanPostProcessor 都隐式地包含在内。这意味着这两个组件是自动检测并连接在一起的，而不需要 XML 提供的任何 bean 配置元数据。

##### 1.10.4 Using Filters to Customize Scanning

默认情况下，带有@component、@repository、@service、@controller、@configuration 注释的类或带有@component 注释的自定义注释是唯一检测到的候选组件。但是，您可以 通过应用自定义筛选器 来修改和扩展此行为。将它们添加为@componentscan 注释的 includeFilters 或 excludeFilters 属性(或者作为 < context: include-filter/> 或 < context: exclude-filter/> < context: component-scan > element in XML configuration 的子元素)。每个筛选器元素都需要类型和表达式属性。下表描述了过滤选项:

| Filter Type          | Example Expression           | Description                                                  |
| :------------------- | :--------------------------- | :----------------------------------------------------------- |
| annotation (default) | `org.example.SomeAnnotation` | An annotation to be *present* or *meta-present* at the type level in target components. |
| assignable           | `org.example.SomeClass`      | A class (or interface) that the target components are assignable to (extend or implement). |
| aspectj              | `org.example..*Service+`     | An AspectJ type expression to be matched by the target components. |
| regex                | `org\.example\.Default.*`    | A regex expression to be matched by the target components' class names. |
| custom               | `org.example.MyTypeFilter`   | A custom implementation of the `org.springframework.core.type.TypeFilter` interface. |

```java
//忽略所有@repository 注释而使用“ stub”存储库的配置:

@Configuration
@ComponentScan(basePackages = "org.example",
        includeFilters = @Filter(type = FilterType.REGEX, pattern = ".*Stub.*Repository"),
        excludeFilters = @Filter(Repository.class))
public class AppConfig {
    ...
}
```

```xml
<beans>
    <context:component-scan base-package="org.example">
        <context:include-filter type="regex"
                expression=".*Stub.*Repository"/>
        <context:exclude-filter type="annotation"
                expression="org.springframework.stereotype.Repository"/>
    </context:component-scan>
</beans>
```

您还可以通过在注释上设置useDefaultFilters = false或通过将use-default-filters =“ false”作为<component-scan />元素的属性来禁用默认过滤器。 这有效地禁用了对使用@ Component，@ Repository，@ Service，@ Controller，@ RestController或@Configuration进行注释或元注释的类的自动检测。 

##### 1.10.5 Defining Bean Metadata within Components 在组件中定义Bean元数据

Spring 组件还可以向容器提供bean定义元数据。使用与在@Configuration注解类中定义bean元数据相同的@Bean注解来实现。

>除了用于组件初始化的角色外，您还可以将@Lazy批注放置在标有@Autowired或@Inject的注入点上。 在这种情况下，它导致了惰性解析代理的注入。 

```java
@Component
public class FactoryMethodComponent {

    private static int i;

    @Bean
    @Qualifier("public")
    public TestBean publicInstance() {
        return new TestBean("publicInstance");
    }

    // use of a custom qualifier and autowiring of method parameters
    @Bean
    protected TestBean protectedInstance(
            @Qualifier("public") TestBean spouse,
            @Value("#{privateInstance.age}") String country) {
        TestBean tb = new TestBean("protectedInstance", 1);
        tb.setSpouse(spouse);
        tb.setCountry(country);
        return tb;
    }

    @Bean
    private TestBean privateInstance() {
        return new TestBean("privateInstance", i++);
    }

    @Bean
    @RequestScope
    public TestBean requestScopedInstance() {
        return new TestBean("requestScopedInstance", 3);
    }
}
```

> //	todo	组件和@Configuration下的@Bean注入的bean对象由区别？
>
> //https://blog.csdn.net/isea533/article/details/78072133
>
> //https://blog.csdn.net/ttjxtjx/article/details/49866011
>
> // 	解决todo：
>
> <img src="../../../../../../Library/Application%20Support/typora-user-images/image-20210129151937788.png" alt="image-20210129151937788" style="zoom:50%;" />
>
> 用依赖注入获取myService，调用getMode方法。
>
> + @Configuration时，认为myService的mode是service构造函数时生成的，会重新走完mode的实例化，初始化返回一个新的被代理对象。
>
> + @Component时，认为mode是通过TestBeanConfigration注册的bean，获取的是TestBeanConfigration的myMode方法返回一个new MyMode()的Mode对象。
>
> 区别：`@Component`返回的是Mode对象，不会被后处理器处理。更符合java语义。一句话概括就是 `@Configuration` 中所有带 `@Bean` 注解的方法都会被动态代理，因此调用该方法返回的都是同一个实例。
>
> 
>
> 常规 Spring 组件中的@bean 方法与 Spring@Configuration 类中的@bean 方法处理方式不同。不同之处在于,@component 类没有通过 CGLIB 进行增强，以拦截方法和字段的调用。CGLIB 代理是通过调用@configuration 类中的@bean 方法中的方法或字段来创建对协作对象的 bean 元数据引用的方法。这些方法不是用普通的 Java 语义调用的，而是通过容器来提供通常的生命周期管理和 Spring bean 的代理，甚至在通过编程调用@bean 方法引用其他 bean 时也是如此。相比之下，在普通的@component 类中调用@bean 方法中的方法或字段具有标准的 Java 语义，不应用特殊的 CGLIB 处理或其他约束。

>您可以将@bean 方法声明为静态的，这样就可以调用它们，而不需要将它们的包含配置类作为实例来创建。在定义后处理器 bean (例如，BeanFactoryPostProcessor 或 BeanPostProcessor 类型的 bean)时，这是非常有意义的，因为这些 bean 在容器生命周期的早期就被初始化了，并且应该避免在那个时候触发配置的其他部分。（避免prototype bean 在每次初始化的时候都出发配置(后处理器)的其他部分）
>
>由于技术限制，对 static@Bean 方法的调用永远不会被容器截获，甚至在@configuration 类中也不会被截获(如本节前面所述) : CGLIB 子类化只能重写非静态方法。因此，对另一个@bean 方法的直接调用具有标准的 Java 语义，导致直接从工厂方法本身返回一个独立的实例。
>
>@ bean 方法的 Java 语言可见性对 Spring 容器中产生的 bean 定义没有直接影响。您可以自由地声明您的工厂方法，只要您认为适合 non-@Configuration 类和任何地方的静态方法。但是,@configuration 类中的常规@bean 方法需要可重写，也就是说，它们不能声明为 private 或 final。
>
>最后，一个类可以为同一个 bean 保存多个@bean 方法，作为多个工厂方法的安排，根据运行时可用的依赖关系来使用。这与在其他配置场景中选择“ greedistest”构造函数或工厂方法的算法相同: 在构建时选择可满足依赖数量最大的变量，类似于容器如何在多个@autowired 构造函数之间进行选择。

##### 1.10.6 naming autodetected components	命名自动检测的组件